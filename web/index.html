<!-- web/index.html -->
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A2T DreamMall - Meeting Protocol Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        .speaker-0 { color: #3B82F6; } /* Blue */
        .speaker-1 { color: #EF4444; } /* Red */
        .speaker-2 { color: #10B981; } /* Green */
        .speaker-3 { color: #F59E0B; } /* Amber */
        .speaker-4 { color: #8B5CF6; } /* Purple */
        .speaker-5 { color: #EC4899; } /* Pink */
        .speaker-unknown { color: #6B7280; } /* Gray */
        
        .transcript-segment {
            padding: 8px 12px;
            margin: 4px 0;
            border-left: 4px solid;
            background: #F9FAFB;
            border-radius: 0 8px 8px 0;
        }
        
        .timestamp {
            font-size: 0.75rem;
            opacity: 0.7;
            font-family: monospace;
        }
        
        .speaker-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
            margin-right: 8px;
        }
        
        .loading-spinner {
            border: 3px solid #f3f4f6;
            border-top: 3px solid #3B82F6;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen">
    <!-- Header -->
    <header class="bg-white shadow-sm border-b">
        <div class="container mx-auto px-6 py-4">
            <div class="flex items-center justify-between">
                <div>
                    <h1 class="text-2xl font-bold text-gray-800">A2T DreamMall</h1>
                    <p class="text-sm text-gray-600">Audio-zu-Text Meeting Protocol Generator</p>
                </div>
                <div class="text-sm text-gray-500">
                    v1.0.0 | KI-gest√ºtzt
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="container mx-auto px-6 py-8">
        
        <!-- Models Overview Section -->
        <div class="bg-white rounded-lg shadow-sm border p-6 mb-8">
            <div class="flex items-center justify-between mb-4">
                <h2 class="text-xl font-semibold flex items-center">
                    <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 3v2m6-2v2M9 19v2m6-2v2M5 9H3m2 6H3m18-6h-2m2 6h-2M7 19h10a2 2 0 002-2V7a2 2 0 00-2-2H7a2 2 0 00-2 2v10a2 2 0 002 2zM9 9h6v6H9V9z"></path>
                    </svg>
                    Geladene KI-Modelle
                </h2>
                <button id="refreshModelsOverview" class="text-blue-600 hover:text-blue-800 text-sm px-3 py-1 border border-blue-300 rounded-lg hover:bg-blue-50">
                    üîÑ Aktualisieren
                </button>
            </div>
            
            <div id="modelsOverviewContent" class="space-y-4">
                <div class="text-center py-8">
                    <div class="loading-spinner mx-auto"></div>
                    <p class="text-gray-500 mt-2">Lade Modellinformationen...</p>
                </div>
            </div>
        </div>
        
        <!-- Upload Section -->
        <div class="bg-white rounded-lg shadow-sm border p-6 mb-8">
            <h2 class="text-xl font-semibold mb-4 flex items-center">
                <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
                </svg>
                Audio-Datei hochladen
            </h2>
            
            <!-- Model Selection -->
            <div class="mb-4">
                <label for="modelSelect" class="block text-sm font-medium text-gray-700 mb-2">
                    Whisper Modell w√§hlen
                </label>
                <select id="modelSelect" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                    <!-- Modelle werden dynamisch geladen -->
                    <option value="small" selected>Small (244 MB) üåü - Empfohlen (Standard)</option>
                </select>
                <div class="flex items-center justify-between mt-1">
                    <p class="text-sm text-gray-500">
                        <span id="modelDescription">Gute Qualit√§t, moderate Geschwindigkeit (~6x schneller)</span>
                    </p>
                    <div id="modelLoadingIndicator" class="hidden">
                        <span class="text-xs text-blue-600 bg-blue-50 px-2 py-1 rounded-full animate-pulse">
                            üîÑ Modell wird geladen...
                        </span>
                    </div>
                </div>
                <div id="modelInfo" class="text-xs text-gray-400 mt-1">
                    üåü = Empfohlenes Standard-Modell | ‚úÖ = Aktuell geladen
                </div>
                <!-- Download Warning f√ºr gro√üe Modelle -->
                <div id="modelDownloadWarning" class="hidden mt-2 p-3 bg-yellow-50 border border-yellow-200 rounded-lg">
                    <div class="flex items-start">
                        <div class="flex-shrink-0">
                            <span class="text-yellow-600">‚ö†Ô∏è</span>
                        </div>
                        <div class="ml-2">
                            <h4 class="text-sm font-medium text-yellow-800">Gro√ües Modell wird heruntergeladen</h4>
                            <p class="text-xs text-yellow-700 mt-1">
                                <span id="downloadWarningText">Dieses Modell muss erst heruntergeladen werden.</span>
                            </p>
                            <div class="mt-2 flex space-x-2">
                                <button onclick="confirmModelDownload()" class="text-xs bg-yellow-100 hover:bg-yellow-200 text-yellow-800 px-2 py-1 rounded">
                                    ‚úÖ Fortfahren
                                </button>
                                <button onclick="cancelModelDownload()" class="text-xs bg-gray-100 hover:bg-gray-200 text-gray-800 px-2 py-1 rounded">
                                    ‚ùå Abbrechen
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Current Model Display -->
            <div class="mb-4 p-3 bg-blue-50 rounded-lg">
                <div class="flex items-center justify-between">
                    <div>
                        <span class="text-sm font-medium text-blue-800">Aktuelles Modell:</span>
                        <span id="currentModel" class="text-sm text-blue-600 ml-2">Loading...</span>
                    </div>
                    <button id="refreshModels" class="text-blue-600 hover:text-blue-800 text-sm">
                        üîÑ Aktualisieren
                    </button>
                </div>
            </div>
            
            <!-- File Upload -->
            <div class="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center hover:border-gray-400 transition-colors">
                <input type="file" id="audioFile" accept=".mp3,.wav,.m4a,.mp4,.webm,.ogg" class="hidden" onchange="handleFileSelect(event)">
                <label for="audioFile" class="cursor-pointer">
                    <svg class="mx-auto h-12 w-12 text-gray-400" stroke="currentColor" fill="none" viewBox="0 0 48 48">
                        <path d="M28 8H12a4 4 0 00-4 4v20m32-12v8m0 0v8a4 4 0 01-4 4H12a4 4 0 01-4-4v-4m32-4l-3.172-3.172a4 4 0 00-5.656 0L28 28M8 32l9.172-9.172a4 4 0 015.656 0L28 28m0 0l4 4m4-24h8m-4-4v8m-12 4h.02" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                    <p class="mt-2 text-sm text-gray-600">
                        <span class="font-medium text-blue-600 hover:text-blue-500">Datei ausw√§hlen</span>
                        oder hier hineinziehen
                    </p>
                    <p class="text-xs text-gray-500 mt-1">
                        Unterst√ºtzte Formate: MP3, WAV, M4A, MP4, WebM, OGG
                    </p>
                </label>
            </div>
            
            <button id="processBtn" 
                    class="w-full mt-4 bg-blue-600 text-white py-3 px-4 rounded-lg hover:bg-blue-700 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed" 
                    disabled>
                Verarbeiten
            </button>
            
            <!-- File Info Section -->
            <div id="fileInfo" class="mt-4" style="display: none;">
                <!-- File information will be displayed here -->
            </div>
        </div>

        <!-- Status Section - Detailed Progress Steps -->
        <div id="statusSection" class="hidden bg-white rounded-lg shadow-sm border p-6 mb-8">
            <h3 class="text-lg font-semibold text-gray-800 mb-6 flex items-center">
                <div class="loading-spinner mr-3"></div>
                üîÑ Audio wird verarbeitet...
            </h3>
            
            <!-- Progress Steps -->
            <div class="space-y-4">
                <!-- Step 1: Audio Conversion -->
                <div id="step-conversion" class="flex items-center p-3 rounded-lg border-l-4 border-gray-300 bg-gray-50">
                    <div class="step-icon w-8 h-8 rounded-full bg-gray-300 flex items-center justify-center mr-4">
                        <span class="text-sm font-bold text-gray-600">1</span>
                    </div>
                    <div class="flex-1">
                        <div class="font-medium text-gray-700">Audio-Konvertierung</div>
                        <div class="text-sm text-gray-500">Optimierung f√ºr Whisper...</div>
                    </div>
                    <div class="step-status">
                        <span class="text-gray-400">‚è≥ Warten</span>
                    </div>
                </div>

                <!-- Step 2: Whisper Transcription -->
                <div id="step-transcription" class="flex items-center p-3 rounded-lg border-l-4 border-gray-300 bg-gray-50">
                    <div class="step-icon w-8 h-8 rounded-full bg-gray-300 flex items-center justify-center mr-4">
                        <span class="text-sm font-bold text-gray-600">2</span>
                    </div>
                    <div class="flex-1">
                        <div class="font-medium text-gray-700">Whisper Transkription</div>
                        <div class="text-sm text-gray-500">Sprache zu Text...</div>
                    </div>
                    <div class="step-status">
                        <span class="text-gray-400">‚è≥ Warten</span>
                    </div>
                </div>

                <!-- Step 3: Speaker Diarization -->
                <div id="step-diarization" class="flex items-center p-3 rounded-lg border-l-4 border-gray-300 bg-gray-50">
                    <div class="step-icon w-8 h-8 rounded-full bg-gray-300 flex items-center justify-center mr-4">
                        <span class="text-sm font-bold text-gray-600">3</span>
                    </div>
                    <div class="flex-1">
                        <div class="font-medium text-gray-700">Sprecher-Erkennung</div>
                        <div class="text-sm text-gray-500">PyAnnote Diarization...</div>
                    </div>
                    <div class="step-status">
                        <span class="text-gray-400">‚è≥ Warten</span>
                    </div>
                </div>

                <!-- Step 4: Protocol Generation -->
                <div id="step-protocol" class="flex items-center p-3 rounded-lg border-l-4 border-gray-300 bg-gray-50">
                    <div class="step-icon w-8 h-8 rounded-full bg-gray-300 flex items-center justify-center mr-4">
                        <span class="text-sm font-bold text-gray-600">4</span>
                    </div>
                    <div class="flex-1">
                        <div class="font-medium text-gray-700">Protokoll-Generierung</div>
                        <div class="text-sm text-gray-500">KI erstellt strukturiertes Protokoll...</div>
                    </div>
                    <div class="step-status">
                        <span class="text-gray-400">‚è≥ Warten</span>
                    </div>
                </div>
            </div>

            <!-- Overall Progress Bar -->
            <div class="mt-6">
                <div class="flex justify-between text-sm text-gray-600 mb-2">
                    <span>Gesamtfortschritt</span>
                    <span id="overall-progress-text">0% abgeschlossen</span>
                </div>
                <div class="w-full bg-gray-200 rounded-full h-3">
                    <div id="overall-progress-bar" class="bg-gradient-to-r from-blue-500 to-blue-600 h-3 rounded-full transition-all duration-500 ease-out" style="width: 0%"></div>
                </div>
            </div>

            <!-- Processing Time -->
            <div class="mt-4 text-center">
                <div class="text-sm text-gray-500">
                    <span id="processing-time">Verarbeitungszeit: <span id="elapsed-time">0:00</span></span>
                </div>
            </div>
        </div>

        <!-- Results Section -->
        <div id="resultsSection" class="hidden">
            
            <!-- Analysis Overview -->
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
                <div class="bg-white rounded-lg shadow-sm border p-6">
                    <h3 class="text-sm font-medium text-gray-600 mb-2">Dauer</h3>
                    <div id="durationDisplay" class="text-2xl font-bold text-gray-800">--:--</div>
                </div>
                <div class="bg-white rounded-lg shadow-sm border p-6">
                    <h3 class="text-sm font-medium text-gray-600 mb-2">Sprecher</h3>
                    <div id="speakerCount" class="text-2xl font-bold text-gray-800">-</div>
                </div>
                <div class="bg-white rounded-lg shadow-sm border p-6">
                    <h3 class="text-sm font-medium text-gray-600 mb-2">Sprache</h3>
                    <div id="languageDisplay" class="text-2xl font-bold text-gray-800">-</div>
                </div>
            </div>

            <!-- Speaker Name Configuration -->
            <div id="speakerNamesSection" class="hidden bg-white rounded-lg shadow-sm border mb-8">
                <div class="p-6 border-b">
                    <h2 class="text-lg font-semibold">Sprecher-Namen konfigurieren</h2>
                    <p class="text-sm text-gray-600 mt-1">
                        Geben Sie f√ºr jeden erkannten Sprecher einen Namen ein, bevor Sie das Meeting-Protokoll generieren.
                    </p>
                </div>
                <div id="speakerNamesContent" class="p-6">
                    <!-- Speaker name inputs will be inserted here -->
                </div>
            </div>

            <!-- Transcript Section -->
            <div class="bg-white rounded-lg shadow-sm border mb-8">
                <div class="p-6 border-b">
                    <div class="flex items-center justify-between">
                        <h2 class="text-lg font-semibold">Transkript mit Speaker-Erkennung</h2>
                        <div class="flex items-center space-x-4">
                            <div id="speakerLegend" class="flex items-center space-x-3 text-sm"></div>
                            
                            <!-- Download Options -->
                            <div class="flex items-center space-x-2">
                                <button onclick="downloadTranscriptAsFile()" 
                                        class="flex items-center space-x-2 text-blue-600 hover:text-blue-800 text-sm font-medium px-3 py-2 border border-blue-200 rounded-lg hover:bg-blue-50 transition-colors"
                                        title="Transkript als Textdatei herunterladen">
                                    <span>üìÑ</span>
                                    <span>Transkript</span>
                                </button>
                                <button onclick="downloadCompleteResults()" 
                                        class="flex items-center space-x-2 text-green-600 hover:text-green-800 text-sm font-medium px-3 py-2 border border-green-200 rounded-lg hover:bg-green-50 transition-colors"
                                        title="Alle Daten als JSON herunterladen">
                                    <span>üíæ</span>
                                    <span>Alle Daten</span>
                                </button>
                            </div>
                            
                            <button onclick="toggleTimestamps()" id="timestampToggle"
                                    class="text-sm text-gray-600 hover:text-gray-800">
                                Zeitstempel anzeigen
                            </button>
                        </div>
                    </div>
                </div>
                <div id="transcriptContent" class="p-6 max-h-96 overflow-y-auto">
                    <!-- Transcript segments will be inserted here -->
                </div>
            </div>

            <!-- Protocol Generation -->
            <div id="protocolSection" class="hidden bg-white rounded-lg shadow-sm border">
                <div class="p-6 border-b">
                    <div class="flex items-center justify-between">
                        <h2 class="text-lg font-semibold">KI-Meeting-Protokoll</h2>
                        <div class="flex items-center space-x-4">
                            <!-- Model Selection for Protocol -->
                            <div class="flex items-center space-x-2">
                                <label for="protocolModelSelect" class="text-sm font-medium text-gray-700">
                                    LLM-Modell:
                                </label>
                                <select id="protocolModelSelect" class="px-3 py-2 border border-gray-300 rounded-lg text-sm focus:ring-2 focus:ring-green-500 focus:border-transparent">
                                    <option value="">Lade Modelle...</option>
                                </select>
                            </div>
                            <button onclick="generateProtocol()" id="protocolBtn"
                                    class="bg-green-600 hover:bg-green-700 text-white px-6 py-3 rounded-lg font-medium transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed"
                                    disabled>
                                ü§ñ Protokoll generieren
                            </button>
                            <button onclick="getStructuredProtocolPrompt()" id="promptBtn"
                                    class="bg-blue-600 hover:bg-blue-700 text-white px-6 py-3 rounded-lg font-medium transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed"
                                    disabled>
                                üìù Strukturierter Prompt
                            </button>
                        </div>
                    </div>
                    <p class="text-sm text-gray-600 mt-2">
                        Das KI-Protokoll wird mit den angegebenen Sprecher-Namen und dem gew√§hlten LLM-Modell erstellt.
                        <br>
                        <span class="text-blue-600">üìù Der "Strukturierte Prompt" kann f√ºr externe LLM-Tools kopiert werden.</span>
                    </p>
                    <div id="modelInfo" class="mt-2 p-3 bg-blue-50 rounded-lg text-sm text-blue-700" style="display: none;">
                        <!-- Model information will be displayed here -->
                    </div>
                </div>
                <div id="protocolContent" class="p-6">
                    <div class="text-gray-500 text-center py-8">
                        Konfigurieren Sie zuerst die Sprecher-Namen, dann klicken Sie auf "Protokoll generieren".
                    </div>
                </div>
            </div>
        </div>
    </main>

    <script>
        // Stelle sicher, dass handleFileSelect global verf√ºgbar ist
        function handleFileSelect(event) {
            console.log('üéØ handleFileSelect called', event);
            
            const audioFile = document.getElementById('audioFile');
            const processBtn = document.getElementById('processBtn');
            const fileInfo = document.getElementById('fileInfo');
            
            console.log('üìã Elements found:', {
                audioFile: !!audioFile,
                processBtn: !!processBtn,
                fileInfo: !!fileInfo,
                filesCount: audioFile ? audioFile.files.length : 0
            });
            
            if (!audioFile) {
                console.error('‚ùå audioFile element not found');
                return;
            }
            
            if (!audioFile.files || !audioFile.files.length) {
                console.log('‚ùå No file selected');
                if (processBtn) {
                    processBtn.disabled = true;
                    processBtn.textContent = 'Verarbeiten';
                }
                if (fileInfo) fileInfo.style.display = 'none';
                return;
            }
            
            const file = audioFile.files[0];
            console.log('üìÑ File selected:', {
                name: file.name,
                type: file.type,
                size: `${(file.size / 1024 / 1024).toFixed(2)} MB`
            });
            
            // Show file info immediately
            if (fileInfo) {
                fileInfo.innerHTML = `
                    <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                        <div class="flex items-start space-x-3">
                            <div class="text-blue-500 text-xl">üìÅ</div>
                            <div class="flex-grow">
                                <h4 class="text-blue-800 font-medium">${file.name}</h4>
                                <div class="text-blue-600 text-sm mt-1 space-y-1">
                                    <div>Gr√∂√üe: ${(file.size / 1024 / 1024).toFixed(2)} MB</div>
                                    <div>Typ: ${file.type || 'Unbekannt'}</div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                fileInfo.style.display = 'block';
            }
            
            // Enable process button
            if (processBtn) {
                processBtn.disabled = false;
                processBtn.innerHTML = `
                    <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                    </svg>
                    Verarbeitung starten
                `;
            }
        }
    </script>

    <script>
let currentJobId = null;
let pollInterval = null;

// Model descriptions
const modelDescriptions = {
    "tiny": "Schnellstes Modell, geringste Qualit√§t (~32x schneller) - 39 MB",
    "base": "Ausgewogen zwischen Geschwindigkeit und Qualit√§t (~16x schneller) - 74 MB", 
    "small": "Gute Qualit√§t, moderate Geschwindigkeit (~6x schneller) - 244 MB",
    "medium": "Hohe Qualit√§t, langsamer (~2x schneller) - 769 MB",
    "large": "Beste Qualit√§t, langsamste Verarbeitung (1x) - 1550 MB",
    "large-v2": "Verbesserte Version von Large (1x) - 1550 MB",
    "large-v3": "Neueste Version mit bester Qualit√§t (1x) - 1550 MB"
};

// Add refresh button functionality
document.getElementById('refreshModelsOverview')?.addEventListener('click', loadModelsOverview);

// Load available models on page load
async function loadAvailableModels() {
    console.log('üîÑ Loading available models...');
    try {
        console.log('üì° Fetching from /api/v1/models...');
        const response = await fetch('/api/v1/models');
        console.log('üì° Response status:', response.status);
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        console.log('üìÑ Models data received:', data);
        
        // Store current backend model globally
        currentBackendModel = data.current_model || 'small';
        console.log(`üéØ Current backend model: ${currentBackendModel}`);
        
        // Update current model display
        const currentModelSpan = document.getElementById('currentModel');
        if (currentModelSpan) {
            currentModelSpan.textContent = data.current_model || 'base';
            console.log('‚úÖ Current model updated:', data.current_model);
        }
        
        // Update model select options
        const select = document.getElementById('modelSelect');
        if (select && data.available_models) {
            select.innerHTML = '';
            
            // Sort models by recommended order: small (default), base, medium, large variants, tiny
            const modelOrder = ['small', 'base', 'medium', 'large', 'large-v2', 'large-v3', 'tiny'];
            const sortedModels = Object.entries(data.available_models).sort(([a], [b]) => {
                return modelOrder.indexOf(a) - modelOrder.indexOf(b);
            });
            
            sortedModels.forEach(([model, info]) => {
                const option = document.createElement('option');
                option.value = model;
                
                // Add visual indicators for model status
                const isDefault = model === 'small';
                const isCurrent = model === data.current_model;
                const defaultIndicator = isDefault ? ' üåü' : '';
                const currentIndicator = isCurrent ? ' ‚úÖ' : '';
                
                option.textContent = `${model.charAt(0).toUpperCase() + model.slice(1)} (${info.size})${defaultIndicator}${currentIndicator} - ${info.description}`;
                
                if (model === data.current_model) {
                    option.selected = true;
                }
                select.appendChild(option);
            });
            
            console.log(`‚úÖ Model select updated with ${Object.keys(data.available_models).length} options`);
            console.log(`üåü Default model 'small' ${data.current_model === 'small' ? 'is currently loaded' : 'available for selection'}`);
            
            // Update description for initially selected model
            updateModelDescription();
        }
        
        // Also load models overview
        loadModelsOverview();
        
    } catch (error) {
        console.error('‚ùå Failed to load models:', error);
        
        // Fallback: Set up basic model options
        const currentModelSpan = document.getElementById('currentModel');
        if (currentModelSpan) {
            currentModelSpan.textContent = 'base (offline)';
        }
        
        const select = document.getElementById('modelSelect');
        if (select) {
            select.innerHTML = `
                <option value="tiny">Tiny (39 MB) - Schnellstes Modell</option>
                <option value="base">Base (74 MB) - Ausgewogen</option>
                <option value="small" selected>Small (244 MB) - Empfohlen (Standard)</option>
                <option value="medium">Medium (769 MB) - Hohe Qualit√§t</option>
                <option value="large">Large (1550 MB) - Beste Qualit√§t</option>
                <option value="large-v2">Large-v2 (1550 MB) - Verbesserte Version</option>
                <option value="large-v3">Large-v3 (1550 MB) - Neueste Version</option>
            `;
            console.log('‚úÖ Fallback model options set');
        }
        
        // Try to load models overview anyway
        loadModelsOverview();
    }
}

// Update description when model changes
function updateModelDescription() {
    const select = document.getElementById('modelSelect');
    const descElement = document.getElementById('modelDescription');
    const warningElement = document.getElementById('modelDownloadWarning');
    
    if (select && descElement) {
        const selectedModel = select.value;
        const description = modelDescriptions[selectedModel] || 'Keine Beschreibung verf√ºgbar';
        
        // Enhanced description with download info
        let enhancedDescription = description;
        
        // Add model-specific guidance
        if (selectedModel === 'small') {
            enhancedDescription += ' | üåü Empfohlenes Standard-Modell f√ºr beste Balance';
        } else if (selectedModel === 'tiny') {
            enhancedDescription += ' | ‚ö° Ideal f√ºr schnelle Tests und schwache Hardware';
        } else if (selectedModel.includes('large')) {
            enhancedDescription += ' | üéØ Professionelle Qualit√§t, ben√∂tigt mehr Zeit beim ersten Download';
        } else if (selectedModel === 'medium') {
            enhancedDescription += ' | üìä Hohe Qualit√§t f√ºr wichtige Aufnahmen';
        } else if (selectedModel === 'base') {
            enhancedDescription += ' | ‚öñÔ∏è Guter Kompromiss f√ºr √§ltere Hardware';
        }
        
        descElement.textContent = enhancedDescription;
        
        // Check if download warning should be shown
        checkModelDownloadWarning(selectedModel);
        
        console.log(`üìù Model description updated for: ${selectedModel}`);
    }
}

// Global variable to track current backend model
let currentBackendModel = 'small'; // Default

// Check if download warning should be shown for large models
function checkModelDownloadWarning(selectedModel) {
    const warningElement = document.getElementById('modelDownloadWarning');
    const warningTextElement = document.getElementById('downloadWarningText');
    
    if (!warningElement || !warningTextElement) return;
    
    // Define model sizes for warning
    const modelSizes = {
        'tiny': 39,
        'base': 74, 
        'small': 244,
        'medium': 769,
        'large': 1550,
        'large-v2': 1550,
        'large-v3': 1550
    };
    
    const selectedSize = modelSizes[selectedModel] || 0;
    
    // Show warning for models larger than 500MB if not currently loaded
    if (selectedSize > 500 && selectedModel !== currentBackendModel) {
        const sizeText = selectedSize >= 1000 ? `${(selectedSize/1000).toFixed(1)} GB` : `${selectedSize} MB`;
        const estimatedTime = selectedSize >= 1000 ? '5-15 Minuten' : '2-5 Minuten';
        
        warningTextElement.innerHTML = `
            <strong>${selectedModel.toUpperCase()}</strong> Modell (${sizeText}) muss heruntergeladen werden.<br>
            <span class="text-yellow-600">‚è±Ô∏è Gesch√§tzte Download-Zeit: ${estimatedTime}</span><br>
            <span class="text-yellow-600">üì∂ Abh√§ngig von Ihrer Internetverbindung</span>
        `;
        
        // Store selected model for confirmation
        window.pendingModelSelection = selectedModel;
        
        warningElement.classList.remove('hidden');
        console.log(`‚ö†Ô∏è Download warning shown for ${selectedModel} (${sizeText})`);
    } else {
        warningElement.classList.add('hidden');
        console.log(`‚úÖ No download warning needed for ${selectedModel}`);
    }
}

// Confirm model download
function confirmModelDownload() {
    const warningElement = document.getElementById('modelDownloadWarning');
    const loadingElement = document.getElementById('modelLoadingIndicator');
    const select = document.getElementById('modelSelect');
    
    if (window.pendingModelSelection && select) {
        // Hide warning, show loading
        warningElement.classList.add('hidden');
        loadingElement.classList.remove('hidden');
        
        // Keep the selected model
        select.value = window.pendingModelSelection;
        
        console.log(`‚úÖ User confirmed download of ${window.pendingModelSelection} model`);
        
        // Clear pending selection
        delete window.pendingModelSelection;
        
        // Note: Actual model loading will happen during transcription
        // For now, just update the UI to show the selection is confirmed
        setTimeout(() => {
            loadingElement.classList.add('hidden');
            console.log(`üéØ Model ${select.value} ready for use during transcription`);
        }, 2000);
    }
}

// Cancel model download
function cancelModelDownload() {
    const warningElement = document.getElementById('modelDownloadWarning');
    const select = document.getElementById('modelSelect');
    
    // Hide warning
    warningElement.classList.add('hidden');
    
    // Reset to current backend model
    if (select) {
        select.value = currentBackendModel;
        updateModelDescription();
    }
    
    console.log(`‚ùå User cancelled download, reverted to ${currentBackendModel}`);
    
    // Clear pending selection
    delete window.pendingModelSelection;
}

// Enhanced file selection with validation
function handleFileSelect(event) {
    console.log('üéØ handleFileSelect called', event);
    
    const audioFile = document.getElementById('audioFile');
    const processBtn = document.getElementById('processBtn');
    const fileInfo = document.getElementById('fileInfo');
    
    console.log('üìã Elements found:', {
        audioFile: !!audioFile,
        processBtn: !!processBtn,
        fileInfo: !!fileInfo,
        filesCount: audioFile ? audioFile.files.length : 0
    });
    
    if (!audioFile) {
        console.error('‚ùå audioFile element not found');
        return;
    }
    
    if (!audioFile.files || !audioFile.files.length) {
        console.log('‚ùå No file selected');
        if (processBtn) {
            processBtn.disabled = true;
            processBtn.textContent = 'Verarbeiten';
        }
        if (fileInfo) fileInfo.style.display = 'none';
        return;
    }
    
    const file = audioFile.files[0];
    console.log('üìÑ File selected:', {
        name: file.name,
        type: file.type,
        size: `${(file.size / 1024 / 1024).toFixed(2)} MB`
    });
    
    // Validate file
    const validation = validateAudioFile(file);
    
    if (!validation.valid) {
        console.error('‚ùå File validation failed:', validation.error);
        showFileError(validation.error);
        if (processBtn) processBtn.disabled = true;
        return;
    }
    
    // Show file info
    if (fileInfo) {
        const durationEstimate = estimateProcessingTime(file.size);
        
        fileInfo.innerHTML = `
            <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                <div class="flex items-start space-x-3">
                    <div class="text-blue-500 text-xl">üìÅ</div>
                    <div class="flex-grow">
                        <h4 class="text-blue-800 font-medium">${file.name}</h4>
                        <div class="text-blue-600 text-sm mt-1 space-y-1">
                            <div>Gr√∂√üe: ${(file.size / 1024 / 1024).toFixed(2)} MB</div>
                            <div>Typ: ${file.type || 'Unbekannt'}</div>
                            <div>Gesch√§tzte Verarbeitungszeit: ${durationEstimate}</div>
                        </div>
                        ${file.size > 50 * 1024 * 1024 ? `
                            <div class="mt-2 text-amber-600 text-sm">
                                ‚ö†Ô∏è Gro√üe Datei - Verarbeitung kann l√§nger dauern
                            </div>
                        ` : ''}
                    </div>
                </div>
            </div>
        `;
        fileInfo.style.display = 'block';
    }
    
    // Enable process button
    if (processBtn) {
        processBtn.disabled = false;
        processBtn.innerHTML = `
            <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
            </svg>
            Verarbeitung starten
        `;
    }
}

// Validate audio file
function validateAudioFile(file) {
    const maxSize = 100 * 1024 * 1024; // 100 MB
    const allowedTypes = [
        'audio/mpeg', 'audio/mp3', 'audio/wav', 'audio/wave', 'audio/x-wav',
        'audio/mp4', 'audio/m4a', 'audio/aac', 'audio/ogg', 'audio/webm',
        'audio/flac', 'audio/x-flac'
    ];
    
    const allowedExtensions = [
        '.mp3', '.wav', '.m4a', '.aac', '.ogg', '.webm', '.flac', '.mp4'
    ];
    
    // Check file size
    if (file.size > maxSize) {
        return {
            valid: false,
            error: `Datei zu gro√ü (${(file.size / 1024 / 1024).toFixed(2)} MB). Maximum: 100 MB`
        };
    }
    
    // Check file type and extension
    const fileName = file.name.toLowerCase();
    const hasValidExtension = allowedExtensions.some(ext => fileName.endsWith(ext));
    const hasValidType = allowedTypes.includes(file.type);
    
    if (!hasValidExtension && !hasValidType) {
        return {
            valid: false,
            error: `Ung√ºltiger Dateityp. Unterst√ºtzt: ${allowedExtensions.join(', ')}`
        };
    }
    
    // Check if file is empty
    if (file.size === 0) {
        return {
            valid: false,
            error: 'Datei ist leer'
        };
    }
    
    return { valid: true };
}

// Estimate processing time based on file size
function estimateProcessingTime(fileSize) {
    const sizeMB = fileSize / 1024 / 1024;
    
    if (sizeMB < 5) return '1-2 Minuten';
    if (sizeMB < 20) return '2-5 Minuten';
    if (sizeMB < 50) return '5-10 Minuten';
    return '10+ Minuten';
}

// Show file error
function showFileError(message) {
    const fileInfo = document.getElementById('fileInfo');
    if (fileInfo) {
        fileInfo.innerHTML = `
            <div class="bg-red-50 border border-red-200 rounded-lg p-4">
                <div class="flex items-start space-x-3">
                    <div class="text-red-500 text-xl">‚ùå</div>
                    <div>
                        <h4 class="text-red-800 font-medium">Ung√ºltige Datei</h4>
                        <p class="text-red-600 text-sm mt-1">${message}</p>
                        <div class="mt-2 text-red-600 text-xs">
                            <p><strong>Unterst√ºtzte Formate:</strong> MP3, WAV, M4A, AAC, OGG, FLAC</p>
                            <p><strong>Maximale Gr√∂√üe:</strong> 100 MB</p>
                        </div>
                    </div>
                </div>
            </div>
        `;
        fileInfo.style.display = 'block';
    }
}

// Upload and process audio
async function uploadAudio() {
    console.log('üéØ Upload button clicked!');
    
    const fileInput = document.getElementById('audioFile');
    const modelSelect = document.getElementById('modelSelect');
    const processBtn = document.getElementById('processBtn');
    
    const file = fileInput ? fileInput.files[0] : null;
    
    if (!file) {
        alert('Bitte w√§hlen Sie eine Audio-Datei aus.');
        return;
    }
    
    // Validate file again before upload
    const validation = validateAudioFile(file);
    if (!validation.valid) {
        showFileError(validation.error);
        return;
    }
    
    const selectedModel = modelSelect ? modelSelect.value : 'small';
    console.log('üéØ Selected model:', selectedModel);
    
    // Disable button and show processing status
    if (processBtn) {
        processBtn.disabled = true;
        processBtn.textContent = 'Wird hochgeladen...';
    }
    
    const formData = new FormData();
    formData.append('audio', file);
    formData.append('model', selectedModel);
    
    console.log(`üöÄ Starting upload with model: ${selectedModel}`);
    
    try {
        const response = await fetch('/api/v1/transcribe', {
            method: 'POST',
            body: formData
        });
        
        console.log('üì° Response received:', response.status);
        
        const result = await response.json();
        console.log('üìÑ Response data:', result);
        
        if (response.ok && result.job_id) {
            console.log('‚úÖ Job started with ID:', result.job_id);
            
            // Hide upload section and show processing
            hideUploadSection();
            
            // Start polling for results
            pollForResults(result.job_id);
        } else {
            throw new Error(result.error || 'Upload failed');
        }
    } catch (error) {
        console.error('‚ùå Upload error:', error);
        alert(`Fehler beim Upload: ${error.message}`);
        
        // Re-enable button
        if (processBtn) {
            processBtn.disabled = false;
            processBtn.innerHTML = `
                <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                </svg>
                Verarbeitung starten
            `;
        }
    }
}

// Hide upload section during processing
function hideUploadSection() {
    const uploadSection = document.querySelector('.bg-white.rounded-lg.shadow-sm.border.p-6.mb-8');
    if (uploadSection) {
        uploadSection.style.display = 'none';
    }
    
    // Show processing status section
    const statusSection = document.getElementById('statusSection');
    if (statusSection) {
        statusSection.classList.remove('hidden');
        statusSection.style.display = 'block';
        
        // Initialize all steps to waiting state
        updateProcessingStep('conversion', 'waiting', 'Warten auf Start...');
        updateProcessingStep('transcription', 'waiting', 'Warten...');
        updateProcessingStep('diarization', 'waiting', 'Warten...');
        updateProcessingStep('protocol', 'waiting', 'Warten...');
        
        // Start with first step
        updateProcessingStep('conversion', 'active', 'Audio wird konvertiert...');
        updateOverallProgress(0, 'Audio-Konvertierung gestartet');
        
        // Start processing timer
        startProcessingTimer();
    }
}

// Update processing step status with enhanced visual feedback
function updateProcessingStep(step, status, message) {
    const stepElement = document.getElementById(`step-${step}`);
    if (!stepElement) return;
    
    const iconElement = stepElement.querySelector('.step-icon');
    const statusElement = stepElement.querySelector('.step-status');
    const messageElement = stepElement.querySelector('.text-sm.text-gray-500');
    
    // Remove all status classes
    stepElement.classList.remove('border-gray-300', 'border-blue-500', 'border-green-500', 'border-red-500');
    stepElement.classList.remove('bg-gray-50', 'bg-blue-50', 'bg-green-50', 'bg-red-50');
    
    if (status === 'waiting') {
        stepElement.classList.add('border-gray-300', 'bg-gray-50');
        iconElement.innerHTML = '<span class="text-sm font-bold text-gray-600">' + getStepNumber(step) + '</span>';
        iconElement.className = 'step-icon w-8 h-8 rounded-full bg-gray-300 flex items-center justify-center mr-4';
        statusElement.innerHTML = '<span class="text-gray-400">‚è≥ Warten</span>';
    } else if (status === 'active') {
        stepElement.classList.add('border-blue-500', 'bg-blue-50');
        iconElement.innerHTML = '<div class="w-4 h-4 border-2 border-blue-600 border-t-transparent rounded-full animate-spin"></div>';
        iconElement.className = 'step-icon w-8 h-8 rounded-full bg-blue-500 flex items-center justify-center mr-4';
        statusElement.innerHTML = '<span class="text-blue-600">üîÑ L√§uft...</span>';
    } else if (status === 'completed') {
        stepElement.classList.add('border-green-500', 'bg-green-50');
        iconElement.innerHTML = '<svg class="w-4 h-4 text-white" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path></svg>';
        iconElement.className = 'step-icon w-8 h-8 rounded-full bg-green-500 flex items-center justify-center mr-4';
        statusElement.innerHTML = '<span class="text-green-600">‚úÖ Abgeschlossen</span>';
    } else if (status === 'error') {
        stepElement.classList.add('border-red-500', 'bg-red-50');
        iconElement.innerHTML = '<svg class="w-4 h-4 text-white" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>';
        iconElement.className = 'step-icon w-8 h-8 rounded-full bg-red-500 flex items-center justify-center mr-4';
        statusElement.innerHTML = '<span class="text-red-600">‚ùå Fehler</span>';
    }
    
    // Update message
    if (messageElement) {
        messageElement.textContent = message;
    }
}

// Get step number for display
function getStepNumber(step) {
    const stepNumbers = {
        'conversion': '1',
        'transcription': '2', 
        'diarization': '3',
        'protocol': '4'
    };
    return stepNumbers[step] || '?';
}

// Update overall progress bar
function updateOverallProgress(percentage, statusText) {
    const progressBar = document.getElementById('overall-progress-bar');
    const progressText = document.getElementById('overall-progress-text');
    
    if (progressBar) {
        progressBar.style.width = percentage + '%';
    }
    
    if (progressText) {
        progressText.textContent = Math.round(percentage) + '% - ' + statusText;
    }
}

// Processing timer functionality
let processingStartTime = null;
let processingTimerInterval = null;

function startProcessingTimer() {
    processingStartTime = new Date();
    processingTimerInterval = setInterval(updateProcessingTimer, 1000);
}

function stopProcessingTimer() {
    if (processingTimerInterval) {
        clearInterval(processingTimerInterval);
        processingTimerInterval = null;
    }
}

function updateProcessingTimer() {
    if (!processingStartTime) return;
    
    const now = new Date();
    const elapsed = Math.floor((now - processingStartTime) / 1000);
    
    const minutes = Math.floor(elapsed / 60);
    const seconds = elapsed % 60;
    
    const elapsedTimeElement = document.getElementById('elapsed-time');
    if (elapsedTimeElement) {
        elapsedTimeElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }
}

// Enhanced poll for results with step tracking based on actual backend progress
async function pollForResults(jobId) {
    console.log('üöÄ Starting polling for job:', jobId);
    let attempts = 0;
    const maxAttempts = 120; // 10 minutes timeout
    let currentStep = 'conversion';
    
    const pollInterval = setInterval(async () => {
        attempts++;
        console.log(`üìä Polling attempt ${attempts} for job ${jobId}`);
        
        try {
            const response = await fetch(`/api/v1/status/${jobId}`);
            console.log('üì° Status response:', response.status);
            
            if (!response.ok) {
                console.error('‚ùå Status API error:', response.status, response.statusText);
                const errorText = await response.text();
                console.error('‚ùå Error details:', errorText);
                
                if (response.status === 404) {
                    // Job not found - might be completed and cleaned up
                    // Let's assume it completed successfully after 5 attempts
                    if (attempts > 5) {
                        console.log('ü§î Job not found after several attempts - assuming completion');
                        clearInterval(pollInterval);
                        stopProcessingTimer();
                        
                        // Mark all steps as completed
                        updateProcessingStep('conversion', 'completed', 'Audio optimiert');
                        updateProcessingStep('transcription', 'completed', 'Text extrahiert');
                        updateProcessingStep('diarization', 'completed', 'Sprecher erkannt');
                        updateProcessingStep('protocol', 'completed', 'Protokoll erstellt');
                        updateOverallProgress(100, 'Verarbeitung abgeschlossen!');
                        
                        // Show a fallback result
                        const fallbackResult = {
                            transcript: 'Verarbeitung abgeschlossen, aber Ergebnis konnte nicht abgerufen werden.',
                            segments: [],
                            speakers: [],
                            protocol_text: 'Protokoll wurde erstellt, aber ist nicht verf√ºgbar.',
                            metadata: {
                                duration: 0,
                                duration_formatted: '0:00',
                                speaker_count: 0,
                                language: 'de'
                            }
                        };
                        
                        setTimeout(() => {
                            displayResults(fallbackResult);
                        }, 1000);
                    }
                    return;
                }
                return;
            }
            
            const data = await response.json();
            console.log('üìÑ Status data:', data);
            
            // Update steps based on backend status and progress
            if (data.status === 'processing') {
                console.log(`üìä Processing... Progress: ${data.progress}%, Current step: ${currentStep}`);
                
                // Step 1: Audio Conversion (0-15%)
                if (data.progress >= 0 && currentStep === 'conversion') {
                    updateProcessingStep('conversion', 'active', 'Audio wird f√ºr Whisper optimiert...');
                    updateOverallProgress(5, 'Audio-Konvertierung l√§uft');
                }
                
                if (data.progress >= 15) {
                    updateProcessingStep('conversion', 'completed', 'Audio-Konvertierung abgeschlossen');
                    // Check if model is loading for better user feedback
                    if (data.model_loading) {
                        updateProcessingStep('transcription', 'active', `üîÑ Whisper-Modell "${data.target_model}" wird geladen... (kann bei gro√üen Modellen l√§nger dauern)`);
                    } else {
                        updateProcessingStep('transcription', 'active', 'Whisper Transkription l√§uft...');
                    }
                    currentStep = 'transcription';
                    updateOverallProgress(25, 'Sprach-zu-Text Konvertierung');
                }
                
                // Step 2: Whisper Transcription (15-60%)
                if (data.progress >= 30 && currentStep === 'transcription') {
                    updateOverallProgress(40, 'Whisper verarbeitet Audio...');
                }
                
                if (data.progress >= 60) {
                    updateProcessingStep('transcription', 'completed', 'Transkription abgeschlossen');
                    updateProcessingStep('diarization', 'active', 'PyAnnote Sprecher-Erkennung...');
                    currentStep = 'diarization';
                    updateOverallProgress(65, 'Sprecher werden erkannt');
                }
                
                // Step 3: Speaker Diarization (60-80%)
                if (data.progress >= 70 && currentStep === 'diarization') {
                    updateOverallProgress(75, 'Sprecher-Segmente werden zugeordnet');
                }
                
                if (data.progress >= 80) {
                    updateProcessingStep('diarization', 'completed', 'Sprecher-Erkennung abgeschlossen');
                    updateProcessingStep('protocol', 'active', 'KI generiert Protokoll...');
                    currentStep = 'protocol';
                    updateOverallProgress(85, 'Protokoll wird erstellt');
                }
                
                // Step 4: Protocol Generation (80-95%)
                if (data.progress >= 90 && currentStep === 'protocol') {
                    updateOverallProgress(95, 'Protokoll wird finalisiert...');
                }
            }
            
            if (data.status === 'completed') {
                console.log('‚úÖ Job completed successfully!');
                clearInterval(pollInterval);
                stopProcessingTimer();
                
                // Complete all steps
                updateProcessingStep('conversion', 'completed', 'Audio optimiert');
                updateProcessingStep('transcription', 'completed', 'Text extrahiert');
                updateProcessingStep('diarization', 'completed', 'Sprecher erkannt');
                updateProcessingStep('protocol', 'completed', 'Protokoll erstellt');
                updateOverallProgress(100, 'Verarbeitung abgeschlossen!');
                
                // Show completion animation
                setTimeout(() => {
                    const statusSection = document.getElementById('statusSection');
                    if (statusSection) {
                        statusSection.style.transform = 'scale(0.98)';
                        statusSection.style.opacity = '0.8';
                        
                        setTimeout(() => {
                            displayResults(data.result);
                        }, 300);
                    }
                }, 500);
                
            } else if (data.status === 'failed') {
                console.error('‚ùå Job failed:', data.error);
                clearInterval(pollInterval);
                stopProcessingTimer();
                
                // Mark current step as failed
                updateProcessingStep(currentStep, 'error', 'Fehler aufgetreten');
                updateOverallProgress(0, 'Verarbeitung fehlgeschlagen');
                
                showError(data.error || 'Processing failed');
                
            } else if (attempts >= maxAttempts) {
                console.error('‚ùå Polling timeout reached');
                clearInterval(pollInterval);
                stopProcessingTimer();
                updateProcessingStep(currentStep, 'error', 'Timeout erreicht');
                showError('Timeout: Processing took too long');
            }
            
        } catch (error) {
            console.error('‚ùå Polling error:', error);
            attempts += 5; // Fast fail on network errors
        }
        
        // Show timeout warning after 2 minutes
        if (attempts > 24 && attempts % 12 === 0) {
            console.log('‚ö†Ô∏è Showing timeout warning');
            const processingTime = document.getElementById('processing-time');
            if (processingTime) {
                processingTime.innerHTML = `
                    <span class="text-amber-600">‚ö†Ô∏è Verarbeitung dauert l√§nger als erwartet</span><br>
                    <span class="text-sm">Verarbeitungszeit: <span id="elapsed-time">0:00</span></span>
                `;
            }
        }
        
    }, 3000); // Poll every 3 seconds for faster response
}

// Display results
function displayResults(result) {
    console.log('üéâ Showing results:', result);
    
    // Stop processing timer
    stopProcessingTimer();
    
    // Hide processing status
    const statusSection = document.getElementById('statusSection');
    if (statusSection) {
        statusSection.style.display = 'none';
    }
    
    // Show results section
    const resultsSection = document.getElementById('resultsSection');
    if (resultsSection) {
        resultsSection.classList.remove('hidden');
        resultsSection.style.display = 'block';
    }
    
    // Update metadata displays
    const metadata = result.metadata || {};
    
    const durationDisplay = document.getElementById('durationDisplay');
    if (durationDisplay) {
        durationDisplay.textContent = metadata.duration_formatted || formatTime(metadata.duration || 0);
    }
    
    const speakerCount = document.getElementById('speakerCount');
    if (speakerCount) {
        const speakers = result.segments ? [...new Set(result.segments.map(s => s.speaker))].length : 1;
        speakerCount.textContent = speakers;
    }
    
    const languageDisplay = document.getElementById('languageDisplay');
    if (languageDisplay) {
        languageDisplay.textContent = (metadata.language || 'de').toUpperCase();
    }
    
    // Display transcript with speaker information
    displayTranscript(result);
    
    // Scroll to results
    resultsSection.scrollIntoView({ behavior: 'smooth' });
}

// Show error
function showError(message) {
    const statusSection = document.getElementById('statusSection');
    if (statusSection) {
        statusSection.innerHTML = `
            <div class="text-center">
                <div class="text-red-500 text-6xl mb-4">‚ùå</div>
                <h3 class="text-lg font-semibold text-red-800 mb-2">Fehler bei der Verarbeitung</h3>
                <p class="text-red-600 mb-4">${message}</p>
                <button onclick="resetUpload()" class="bg-blue-600 text-white py-2 px-4 rounded-lg hover:bg-blue-700">
                    Erneut versuchen
                </button>
            </div>
        `;
        statusSection.style.display = 'block';
    }
}

// Display transcript with speakers
let currentTranscriptData = null; // Store transcript data for protocol generation
let speakerNames = {}; // Store speaker name mappings

function displayTranscript(data) {
    const transcriptContent = document.getElementById('transcriptContent');
    
    if (!transcriptContent) return;
    
    // Store data for later use
    currentTranscriptData = data;
    
    let segments = [];
    
    // Use segments if available
    if (data.segments && data.segments.length > 0) {
        segments = data.segments;
    } else {
        // Fallback: create single segment
        segments = [{
            speaker: 'SPEAKER_01',
            text: data.transcript || 'Kein Transkript verf√ºgbar',
            start: 0,
            end: data.metadata?.duration || 0
        }];
    }
    
    // Get unique speakers for color coding
    const speakers = [...new Set(segments.map(s => s.speaker))];
    
    // Handle edge case: no speakers detected
    if (speakers.length === 0) {
        console.warn('‚ö†Ô∏è No speakers detected, creating default speaker');
        speakers.push('SPEAKER_01');
        segments = segments.length > 0 ? segments : [{
            speaker: 'SPEAKER_01',
            text: data.transcript || 'Kein Transkript verf√ºgbar',
            start: 0,
            end: data.metadata?.duration || 0
        }];
    }
    
    // Initialize speaker names with defaults
    speakerNames = {};
    speakers.forEach((speaker, index) => {
        if (speakers.length === 1) {
            speakerNames[speaker] = 'Sprecher';
        } else {
            speakerNames[speaker] = `Person ${index + 1}`;
        }
    });
    
    // Show appropriate UI based on speaker count
    if (speakers.length === 1) {
        // Single speaker - no need for complex name assignment
        displaySingleSpeakerMessage();
    } else {
        // Multiple speakers - show name assignment UI
        displaySpeakerNamesConfig(speakers);
    }
    
    // Create transcript HTML
    transcriptContent.innerHTML = segments.map((segment, index) => {
        const speakerIndex = speakers.indexOf(segment.speaker);
        const speakerColor = getSpeakerColor(speakerIndex);
        
        return `
            <div class="transcript-segment border-l-4 pl-4 py-2" style="border-left-color: ${speakerColor};">
                <div class="flex items-center justify-between mb-1">
                    <span class="speaker-badge px-2 py-1 rounded text-xs font-medium" style="background-color: ${speakerColor}20; color: ${speakerColor};">
                        <span class="speaker-display" data-speaker="${segment.speaker}">${speakerNames[segment.speaker]}</span>
                    </span>
                    <span class="timestamp text-xs text-gray-500">
                        ${formatTime(segment.start)} - ${formatTime(segment.end)}
                    </span>
                </div>
                <div class="text-gray-800">${segment.text}</div>
            </div>
        `;
    }).join('');
    
    // Show speaker legend
    updateSpeakerLegend(speakers);
}

// Display message for single speaker scenarios
function displaySingleSpeakerMessage() {
    const speakerNamesSection = document.getElementById('speakerNamesSection');
    const speakerNamesContent = document.getElementById('speakerNamesContent');
    
    if (!speakerNamesSection || !speakerNamesContent) return;
    
    // Show the section
    speakerNamesSection.classList.remove('hidden');
    
    speakerNamesContent.innerHTML = `
        <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
            <div class="flex items-center space-x-3">
                <div class="text-blue-500 text-xl">üë§</div>
                <div>
                    <h3 class="text-blue-800 font-medium">Ein Sprecher erkannt</h3>
                    <p class="text-blue-600 text-sm mt-1">
                        Es wurde nur ein Sprecher erkannt oder die Sprecher-Erkennung war nicht verf√ºgbar.
                        Das Protokoll wird f√ºr eine Person erstellt.
                    </p>
                </div>
            </div>
            
            <div class="mt-4">
                <label for="single_speaker_name" class="block text-sm font-medium text-gray-700 mb-2">
                    Name f√ºr den Sprecher (optional):
                </label>
                <div class="flex space-x-3">
                    <input 
                        type="text" 
                        id="single_speaker_name" 
                        class="flex-grow px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                        placeholder="z.B. Max Mustermann"
                        value="${Object.values(speakerNames)[0] || 'Sprecher'}"
                        onchange="updateSingleSpeakerName(this.value)"
                    >
                    <button 
                        onclick="confirmSpeakerNames()" 
                        class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg font-medium transition-colors">
                        ‚úÖ Best√§tigen
                    </button>
                </div>
            </div>
        </div>
    `;
}

// Display speaker names configuration
function displaySpeakerNamesConfig(speakers) {
    const speakerNamesSection = document.getElementById('speakerNamesSection');
    const speakerNamesContent = document.getElementById('speakerNamesContent');
    
    if (!speakerNamesSection || !speakerNamesContent) return;
    
    // Show the section
    speakerNamesSection.classList.remove('hidden');
    
    // Create input fields for each speaker
    speakerNamesContent.innerHTML = speakers.map((speaker, index) => {
        const speakerColor = getSpeakerColor(index);
        
        return `
            <div class="mb-4 p-4 border rounded-lg" style="border-left: 4px solid ${speakerColor};">
                <div class="flex items-center space-x-4">
                    <div class="flex-shrink-0">
                        <span class="speaker-badge px-3 py-2 rounded text-sm font-medium" style="background-color: ${speakerColor}20; color: ${speakerColor};">
                            ${speaker}
                        </span>
                    </div>
                    <div class="flex-grow">
                        <label for="name_${speaker}" class="block text-sm font-medium text-gray-700 mb-1">
                            Name f√ºr diesen Sprecher:
                        </label>
                        <input 
                            type="text" 
                            id="name_${speaker}" 
                            data-speaker="${speaker}"
                            class="speaker-name-input w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                            placeholder="z.B. Max Mustermann, Projektleiter, etc."
                            value="${speakerNames[speaker]}"
                            onchange="updateSpeakerName('${speaker}', this.value)"
                        >
                    </div>
                </div>
            </div>
        `;
    }).join('');
    
    // Add confirmation button
    speakerNamesContent.innerHTML += `
        <div class="mt-6 pt-4 border-t">
            <div class="flex justify-between items-center">
                <p class="text-sm text-gray-600">
                    Sprecher-Namen konfiguriert. Sie k√∂nnen das Meeting-Protokoll generieren.
                </p>
                <button 
                    onclick="confirmSpeakerNames()" 
                    class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg font-medium transition-colors">
                    ‚úÖ Namen best√§tigen
                </button>
            </div>
        </div>
    `;
}

// Update single speaker name
function updateSingleSpeakerName(newName) {
    const speakerId = Object.keys(speakerNames)[0];
    if (speakerId) {
        speakerNames[speakerId] = newName || 'Sprecher';
        updateTranscriptSpeakerNames();
        updateSpeakerLegend([speakerId]);
    }
}

// Update speaker name
function updateSpeakerName(speaker, newName) {
    speakerNames[speaker] = newName || `Person ${Object.keys(speakerNames).indexOf(speaker) + 1}`;
    
    // Update transcript display
    updateTranscriptSpeakerNames();
    updateSpeakerLegend(Object.keys(speakerNames));
}

// Update transcript speaker names in real-time
function updateTranscriptSpeakerNames() {
    const speakerDisplays = document.querySelectorAll('.speaker-display');
    speakerDisplays.forEach(display => {
        const speaker = display.getAttribute('data-speaker');
        if (speakerNames[speaker]) {
            display.textContent = speakerNames[speaker];
        }
    });
}

// Update speaker legend
function updateSpeakerLegend(speakers) {
    const speakerLegend = document.getElementById('speakerLegend');
    if (!speakerLegend) return;
    
    speakerLegend.innerHTML = speakers.map((speaker, index) => {
        const speakerColor = getSpeakerColor(index);
        const displayName = speakerNames[speaker] || speaker;
        
        return `
            <span class="flex items-center">
                <span class="w-3 h-3 rounded-full mr-2" style="background-color: ${speakerColor};"></span>
                <span class="text-sm">${displayName}</span>
            </span>
        `;
    }).join('');
}

// Confirm speaker names and enable protocol generation
function confirmSpeakerNames() {
    const protocolSection = document.getElementById('protocolSection');
    const protocolBtn = document.getElementById('protocolBtn');
    
    // Show protocol section
    if (protocolSection) {
        protocolSection.classList.remove('hidden');
    }
    
    // Load Ollama models when protocol section becomes available
    loadOllamaModels();
    
    // Enable protocol buttons
    if (protocolBtn) {
        protocolBtn.disabled = false;
    }
    
    const promptBtn = document.getElementById('promptBtn');
    if (promptBtn) {
        promptBtn.disabled = false;
    }
    
    // Scroll to protocol section
    if (protocolSection) {
        protocolSection.scrollIntoView({ behavior: 'smooth' });
    }
    
    // Show success message
    const speakerNamesContent = document.getElementById('speakerNamesContent');
    if (speakerNamesContent) {
        const successMsg = document.createElement('div');
        successMsg.className = 'mt-4 p-3 bg-green-100 border border-green-400 text-green-700 rounded-lg';
        successMsg.innerHTML = '‚úÖ Sprecher-Namen best√§tigt! Sie k√∂nnen jetzt das Meeting-Protokoll generieren.';
        speakerNamesContent.appendChild(successMsg);
    }
}

// Get speaker color
function getSpeakerColor(index) {
    const colors = [
        '#3B82F6', // Blue
        '#EF4444', // Red  
        '#10B981', // Green
        '#F59E0B', // Amber
        '#8B5CF6', // Purple
        '#EC4899'  // Pink
    ];
    return colors[index % colors.length];
}

// Format time helper
function formatTime(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
}

// Reset upload
function resetUpload() {
    location.reload();
}

// Initialize page with all event handlers
document.addEventListener('DOMContentLoaded', function() {
    console.log('üöÄ Page loaded, initializing...');
    
    // Load available models
    loadAvailableModels();
    loadOllamaModels();
    
    // Set up event handlers
    const audioFile = document.getElementById('audioFile');
    const processBtn = document.getElementById('processBtn');
    const modelSelect = document.getElementById('modelSelect');
    const refreshModels = document.getElementById('refreshModels');
    
    // File selection handler
    if (audioFile) {
        audioFile.addEventListener('change', handleFileSelect);
        console.log('‚úÖ File input event listener added');
    } else {
        console.error('‚ùå Audio file input not found');
    }
    
    // Process button handler  
    if (processBtn) {
        processBtn.addEventListener('click', uploadAudio);
        console.log('‚úÖ Process button event listener added');
    } else {
        console.error('‚ùå Process button not found');
    }
    
    // Model selection handler
    if (modelSelect) {
        modelSelect.addEventListener('change', updateModelDescription);
        console.log('‚úÖ Model select event listener added');
    }
    
    // Refresh models handler
    if (refreshModels) {
        refreshModels.addEventListener('click', loadAvailableModels);
        console.log('‚úÖ Refresh models event listener added');
    }
    
    // Protocol model selection handler
    const protocolModelSelect = document.getElementById('protocolModelSelect');
    if (protocolModelSelect) {
        protocolModelSelect.addEventListener('change', updateProtocolModelInfo);
        console.log('‚úÖ Protocol model select event listener added');
    }
    
    // Add drag and drop support
    setupDragAndDrop();
    
    console.log('‚úÖ All event handlers initialized');
});

// Setup drag and drop
function setupDragAndDrop() {
    const uploadArea = document.querySelector('.border-dashed');
    if (!uploadArea) {
        console.error('‚ùå Upload area not found for drag and drop');
        return;
    }
    
    uploadArea.addEventListener('dragover', function(e) {
        e.preventDefault();
        e.stopPropagation();
        uploadArea.classList.add('border-blue-400', 'bg-blue-50');
    });
    
    uploadArea.addEventListener('dragleave', function(e) {
        e.preventDefault();
        e.stopPropagation();
        uploadArea.classList.remove('border-blue-400', 'bg-blue-50');
    });
    
    uploadArea.addEventListener('drop', function(e) {
        e.preventDefault();
        e.stopPropagation();
        uploadArea.classList.remove('border-blue-400', 'bg-blue-50');
        
        console.log('üéØ File dropped!', e.dataTransfer.files);
        const files = e.dataTransfer.files;
        if (files.length > 0) {
            const audioFile = document.getElementById('audioFile');
            if (audioFile) {
                // Create a new FileList and assign it
                const dt = new DataTransfer();
                dt.items.add(files[0]);
                audioFile.files = dt.files;
                handleFileSelect(e);
                console.log('‚úÖ File dropped and selected:', files[0].name);
            }
        }
    });
    
    console.log('‚úÖ Drag and drop setup completed');
}

// Ollama Models Management
let ollamaModels = [];
let selectedProtocolModel = null;

// Load available Ollama models for protocol generation
async function loadOllamaModels() {
    console.log('ü§ñ Loading available Ollama models...');
    try {
        const response = await fetch('/api/v1/ollama/models');
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        
        console.log('ü§ñ Ollama models response:', data);
        
        const modelSelect = document.getElementById('protocolModelSelect');
        const modelInfo = document.getElementById('modelInfo');
        
        // Handle different scenarios more precisely
        if (!data.available) {
            // Ollama server not reachable
            if (modelSelect) {
                modelSelect.innerHTML = '<option value="">Ollama Server nicht erreichbar</option>';
                modelSelect.disabled = true;
            }
            
            if (modelInfo) {
                modelInfo.innerHTML = `
                    ‚ùå Ollama-Server nicht erreichbar (${data.error || 'Unbekannter Fehler'})
                    <br><small>Starten Sie Ollama mit "ollama serve" f√ºr erweiterte KI-Protokolle.</small>
                `;
                modelInfo.className = 'mt-2 p-3 bg-red-50 rounded-lg text-sm text-red-700';
                modelInfo.style.display = 'block';
            }
            
            console.log('‚ùå Ollama server not available:', data.error);
            return;
        }
        
        if (!data.models || data.models.length === 0) {
            // Ollama server available but no models loaded
            if (modelSelect) {
                modelSelect.innerHTML = '<option value="">Keine Modelle geladen</option>';
                modelSelect.disabled = true;
            }
            
            if (modelInfo) {
                modelInfo.innerHTML = `
                    ‚ö†Ô∏è Ollama-Server l√§uft, aber keine Modelle geladen.
                    <br><small>Laden Sie Modelle mit "ollama pull llama3" oder √§hnlich.</small>
                `;
                modelInfo.className = 'mt-2 p-3 bg-yellow-50 rounded-lg text-sm text-yellow-700';
                modelInfo.style.display = 'block';
            }
            
            console.log('‚ö†Ô∏è Ollama available but no models loaded');
            return;
        }
        
        // Ollama available with models - populate select
        ollamaModels = data.models;
        
        if (modelSelect) {
            modelSelect.innerHTML = '';
            
            // Add models to select
            data.models.forEach(model => {
                const option = document.createElement('option');
                option.value = model.name;
                option.textContent = `${model.name} (${model.parameter_size}, ${model.size_formatted})`;
                
                // Mark recommended models
                if (model.recommended) {
                    option.textContent += ' ‚≠ê Empfohlen';
                    option.selected = true;
                    selectedProtocolModel = model.name;
                }
                
                modelSelect.appendChild(option);
            });
            
            // Set default if no recommended model selected
            if (!selectedProtocolModel && data.models.length > 0) {
                selectedProtocolModel = data.models[0].name;
                modelSelect.value = selectedProtocolModel;
            }
            
            modelSelect.disabled = false;
            console.log(`‚úÖ Loaded ${data.models.length} Ollama models`);
            
            // Update model info with success message
            if (modelInfo) {
                modelInfo.innerHTML = `
                    ‚úÖ ${data.models.length} Ollama-Modelle verf√ºgbar (Server: ${data.base_url})
                    <br><small>Standard: ${data.current_default}</small>
                `;
                modelInfo.className = 'mt-2 p-3 bg-green-50 rounded-lg text-sm text-green-700';
                modelInfo.style.display = 'block';
            }
        }
        
    } catch (error) {
        console.error('‚ùå Failed to load Ollama models:', error);
        
        const modelSelect = document.getElementById('protocolModelSelect');
        const modelInfo = document.getElementById('modelInfo');
        
        if (modelSelect) {
            modelSelect.innerHTML = '<option value="">Netzwerk-Fehler</option>';
            modelSelect.disabled = true;
        }
        
        if (modelInfo) {
            const errorMessage = error.message || 'Unbekannter Fehler';
            modelInfo.innerHTML = `
                ‚ùå Fehler beim Laden der Ollama-Modelle: ${errorMessage}
                <br><small>Fallback-Protokolle sind weiterhin verf√ºgbar.</small>
            `;
            modelInfo.className = 'mt-2 p-3 bg-red-50 rounded-lg text-sm text-red-700';
            modelInfo.style.display = 'block';
        }
    }
}

// Process transcript with real names for protocol generation
function processTranscriptWithNames() {
    if (!currentTranscriptData || !currentTranscriptData.segments) {
        console.log('‚ö†Ô∏è No transcript data available');
        return currentTranscriptData?.transcript || '';
    }
    
    let processedTranscript = '';
    
    // Process each segment with speaker names
    currentTranscriptData.segments.forEach(segment => {
        const speaker = segment.speaker;
        const text = segment.text;
        const start = segment.start;
        const end = segment.end;
        
        // Get the real name for this speaker
        const realName = speakerNames[speaker] || speaker;
        
        // Add to processed transcript
        processedTranscript += `[${formatTime(start)}-${formatTime(end)}] ${realName}: ${text}\n`;
    });
    
    // If no segments, use plain transcript
    if (!processedTranscript) {
        processedTranscript = currentTranscriptData.transcript;
    }
    
    console.log('üìù Processed transcript with names:', processedTranscript.length + ' characters');
    return processedTranscript;
}

// Create speaker list with real names
function createSpeakerList() {
    const speakers = [];
    
    // Convert speakerNames object to array format expected by backend
    Object.keys(speakerNames).forEach(speakerId => {
        speakers.push({
            id: speakerId,
            name: speakerNames[speakerId],
            original_id: speakerId
        });
    });
    
    console.log('üë• Created speaker list:', speakers);
    return speakers;
}

// Generate simple fallback protocol
function generateSimpleFallbackProtocol() {
    if (!currentTranscriptData) {
        return 'Keine Transkriptionsdaten verf√ºgbar.';
    }
    
    const transcript = currentTranscriptData.transcript;
    const segments = currentTranscriptData.segments || [];
    const metadata = currentTranscriptData.metadata || {};
    
    // Basic protocol structure
    let protocol = `# Meeting-Protokoll\n`;
    protocol += `*Automatisch generiert am ${new Date().toLocaleString('de-DE')}*\n\n`;
    
    // Meeting info
    protocol += `## Meeting-Informationen\n`;
    protocol += `- **Dauer:** ${metadata.duration_formatted || 'Unbekannt'}\n`;
    protocol += `- **Sprache:** ${metadata.language || 'Deutsch'}\n`;
    protocol += `- **Sprecher:** ${metadata.speaker_count || 1}\n`;
    protocol += `- **Segmente:** ${segments.length}\n\n`;
    
    // Participants
    protocol += `## Teilnehmer\n`;
    Object.values(speakerNames).forEach(name => {
        protocol += `- ${name}\n`;
    });
    protocol += `\n`;
    
    // Transcript with timestamps
    protocol += `## Transkription\n`;
    if (segments.length > 0) {
        segments.forEach(segment => {
            const speaker = speakerNames[segment.speaker] || segment.speaker;
            const timeStamp = `${formatTime(segment.start)}-${formatTime(segment.end)}`;
            protocol += `**${speaker}** *(${timeStamp})*: ${segment.text}\n\n`;
        });
    } else {
        protocol += `${transcript}\n\n`;
    }
    
    // Basic structure for action items
    protocol += `## Erkannte Themen\n`;
    protocol += `*Automatische Analyse:*\n`;
    
    // Simple keyword analysis
    const words = transcript.toLowerCase().split(/\s+/);
    const keywords = {
        'entscheidung': ['entscheidung', 'beschluss', 'entscheiden', 'beschlie√üen'],
        'aufgabe': ['aufgabe', 'todo', 'erledigen', 'zust√§ndig', 'verantwortlich'],
        'termin': ['termin', 'deadline', 'bis', 'datum', 'zeit'],
        'problem': ['problem', 'issue', 'fehler', 'schwierigkeit']
    };
    
    Object.keys(keywords).forEach(category => {
        const matches = keywords[category].filter(word => words.includes(word));
        if (matches.length > 0) {
            protocol += `- **${category.charAt(0).toUpperCase() + category.slice(1)}** erw√§hnt (${matches.length}x)\n`;
        }
    });
    
    protocol += `\n## N√§chste Schritte\n`;
    protocol += `- [ ] Protokoll √ºberpr√ºfen und vervollst√§ndigen\n`;
    protocol += `- [ ] Action Items definieren\n`;
    protocol += `- [ ] N√§chstes Meeting planen\n\n`;
    
    protocol += `---\n`;
    protocol += `*Dieses Protokoll wurde automatisch aus der Audio-Transkription generiert.*\n`;
    protocol += `*F√ºr bessere Qualit√§t verwenden Sie ein KI-Modell √ºber Ollama.*\n`;
    
    return protocol;
}

// Copy protocol to clipboard
function copyProtocolToClipboard() {
    const protocolText = document.getElementById('protocolText');
    if (!protocolText) return;
    
    navigator.clipboard.writeText(protocolText.textContent).then(() => {
        // Show success message
        const button = event.target;
        const originalText = button.innerHTML;
        button.innerHTML = '‚úÖ Kopiert!';
        button.style.backgroundColor = '#10b981';
        
        setTimeout(() => {
            button.innerHTML = originalText;
            button.style.backgroundColor = '';
        }, 2000);
    }).catch(err => {
        console.error('Failed to copy: ', err);
        alert('Fehler beim Kopieren. Bitte manuell ausw√§hlen und kopieren.');
    });
}

// Download protocol as file
function downloadProtocolAsFile() {
    const protocolText = document.getElementById('protocolText');
    if (!protocolText) return;
    
    const content = protocolText.textContent;
    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
    const filename = `Meeting-Protokoll_${timestamp}.md`;
    
    const blob = new Blob([content], { type: 'text/markdown' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

// Download transcript as formatted text file
function downloadTranscriptAsFile() {
    if (!currentTranscriptData) {
        console.warn('‚ùå No transcript data available for download');
        return;
    }
    
    console.log('üìÑ Downloading transcript as file...');
    
    // Generate formatted transcript with timestamps and speakers
    let content = `# Meeting Transkript\n\n`;
    content += `**Datum:** ${new Date().toLocaleDateString('de-DE')}\n`;
    content += `**Uhrzeit:** ${new Date().toLocaleTimeString('de-DE')}\n`;
    
    if (currentTranscriptData.metadata) {
        content += `**Dauer:** ${currentTranscriptData.metadata.duration_formatted || 'Unbekannt'}\n`;
        content += `**Sprache:** ${currentTranscriptData.metadata.language || 'Unbekannt'}\n`;
        content += `**Sprecher-Anzahl:** ${currentTranscriptData.metadata.speaker_count || 'Unbekannt'}\n`;
        content += `**Whisper-Modell:** ${currentTranscriptData.metadata.whisper_model_used || 'Unbekannt'}\n`;
    }
    
    content += `\n---\n\n`;
    
    // Add full text transcript
    content += `## Volltext-Transkript\n\n`;
    content += `${currentTranscriptData.transcript}\n\n`;
    
    // Add segmented transcript with timestamps and speakers
    if (currentTranscriptData.segments && currentTranscriptData.segments.length > 0) {
        content += `## Detailliertes Transkript mit Zeitstempeln\n\n`;
        
        currentTranscriptData.segments.forEach((segment, index) => {
            const startTime = formatTime(segment.start);
            const endTime = formatTime(segment.end);
            const speaker = segment.speaker || `Sprecher ${index + 1}`;
            const speakerName = speakerNames[speaker] || speaker;
            
            content += `**[${startTime} - ${endTime}] ${speakerName}:**\n`;
            content += `${segment.text.trim()}\n\n`;
        });
    }
    
    // Generate filename with timestamp
    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
    const filename = `Meeting-Transkript_${timestamp}.txt`;
    
    // Create and download file
    const blob = new Blob([content], { type: 'text/plain; charset=utf-8' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    console.log(`‚úÖ Transcript downloaded as: ${filename}`);
}

// Download complete results as JSON file with all data
function downloadCompleteResults() {
    if (!currentTranscriptData) {
        console.warn('‚ùå No transcript data available for download');
        return;
    }
    
    console.log('üíæ Downloading complete results as JSON...');
    
    // Prepare comprehensive data structure
    const completeData = {
        metadata: {
            export_timestamp: new Date().toISOString(),
            export_date: new Date().toLocaleDateString('de-DE'),
            export_time: new Date().toLocaleTimeString('de-DE'),
            version: "A2T-DreamMall v1.0"
        },
        audio_analysis: currentTranscriptData.metadata || {},
        transcript: {
            full_text: currentTranscriptData.transcript,
            language: currentTranscriptData.metadata?.language || 'unknown',
            model_used: currentTranscriptData.metadata?.whisper_model_used || 'unknown'
        },
        segments: currentTranscriptData.segments || [],
        speakers: {
            detected_speakers: currentTranscriptData.speakers || [],
            speaker_names: speakerNames || {},
            speaker_count: currentTranscriptData.metadata?.speaker_count || 0,
            unique_speakers: currentTranscriptData.metadata?.unique_speakers || []
        },
        processing_info: {
            duration: currentTranscriptData.metadata?.duration || 0,
            duration_formatted: currentTranscriptData.metadata?.duration_formatted || 'unknown',
            segments_count: currentTranscriptData.metadata?.segments_count || 0,
            diarization_available: currentTranscriptData.metadata?.diarization_available || false
        }
    };
    
    // Add protocol if available
    const protocolText = document.getElementById('protocolText');
    if (protocolText && protocolText.textContent.trim()) {
        completeData.protocol = {
            generated: true,
            content: protocolText.textContent,
            model_used: selectedProtocolModel || 'unknown',
            generation_timestamp: new Date().toISOString()
        };
    } else {
        completeData.protocol = {
            generated: false,
            content: null,
            reason: "Protocol not generated"
        };
    }
    
    // Generate filename with timestamp
    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
    const filename = `Meeting-Daten-Komplett_${timestamp}.json`;
    
    // Create and download file
    const content = JSON.stringify(completeData, null, 2);
    const blob = new Blob([content], { type: 'application/json; charset=utf-8' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    console.log(`‚úÖ Complete results downloaded as: ${filename}`);
    console.log(`üìä Exported data includes: transcript, segments, speakers, metadata${completeData.protocol.generated ? ', protocol' : ''}`);
}

// Update protocol model info display
function updateProtocolModelInfo() {
    const modelSelect = document.getElementById('protocolModelSelect');
    const modelInfo = document.getElementById('modelInfo');
    
    if (!modelSelect || !modelInfo) return;
    
    selectedProtocolModel = modelSelect.value;
    
    if (!selectedProtocolModel) {
        modelInfo.style.display = 'none';
        return;
    }
    
    // Find model info
    const modelData = ollamaModels.find(m => m.name === selectedProtocolModel);
    
    if (modelData) {
        modelInfo.innerHTML = `
            <div class="flex items-center space-x-3">
                <div class="text-green-600">ü§ñ</div>
                <div class="flex-grow">
                    <div class="font-medium">${modelData.name}</div>
                    <div class="text-sm text-gray-600">
                        ${modelData.parameter_size} ‚Ä¢ ${modelData.size_formatted} ‚Ä¢ ${modelData.quantization}
                        ${modelData.recommended ? ' ‚Ä¢ ‚≠ê Empfohlen' : ''}
                    </div>
                </div>
            </div>
        `;
        modelInfo.className = 'mt-2 p-3 bg-green-50 rounded-lg text-sm';
        modelInfo.style.display = 'block';
    } else {
        modelInfo.style.display = 'none';
    }
}

// Generate protocol with speaker names and selected model
async function generateProtocol() {
    console.log('üéØ Generate Protocol clicked!');
    
    const protocolBtn = document.getElementById('protocolBtn');
    const protocolContent = document.getElementById('protocolContent');
    
    if (!currentTranscriptData) {
        alert('Keine Transkriptionsdaten verf√ºgbar.');
        return;
    }
    
    // Get selected model
    const selectedModel = selectedProtocolModel || document.getElementById('protocolModelSelect')?.value;
    console.log('ü§ñ Selected model for protocol:', selectedModel);
    
    // Disable button and show loading
    if (protocolBtn) {
        protocolBtn.disabled = true;
        protocolBtn.innerHTML = `
            <div class="flex items-center justify-center space-x-2">
                <div class="w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin"></div>
                <span>Protokoll wird generiert...</span>
            </div>
        `;
    }
    
    // Show loading in content area
    if (protocolContent) {
        protocolContent.innerHTML = `
            <div class="text-center py-8">
                <div class="loading-spinner mx-auto mb-4"></div>
                <h3 class="text-lg font-semibold text-gray-800 mb-2">ü§ñ KI generiert Ihr Meeting-Protokoll</h3>
                <p class="text-gray-600 mb-2">Modell: <strong>${selectedModel || 'Fallback'}</strong></p>
                <div class="text-sm text-gray-500">
                    <p>‚ú® Analysiert Transkript und Sprecher-Zuordnungen...</p>
                    <p>üìù Erstellt strukturiertes Protokoll mit Action Items...</p>
                    <p>‚è±Ô∏è Dies kann 10-30 Sekunden dauern</p>
                </div>
            </div>
        `;
    }
    
    try {
        // Prepare transcript with real names
        const processedTranscript = processTranscriptWithNames();
        const processedSpeakers = createSpeakerList();
        
        console.log('üìù Processed transcript length:', processedTranscript.length);
        console.log('üë• Processed speakers:', processedSpeakers);
        
        // Call protocol generation API with model selection
        const requestData = {
            transcript: processedTranscript,
            speakers: processedSpeakers,
            metadata: currentTranscriptData.metadata || {},
            model: selectedModel  // Include selected model
        };
        
        console.log('üöÄ Sending protocol generation request:', requestData);
        
        const response = await fetch('/api/v1/generate-protocol', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(requestData)
        });
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const result = await response.json();
        console.log('‚úÖ Protocol generation response:', result);
        
        // Display protocol
        if (result.success && result.protocol) {
            displayGeneratedProtocol(result);
        } else {
            throw new Error(result.error || 'Protokoll-Generierung fehlgeschlagen');
        }
        
    } catch (error) {
        console.error('‚ùå Protocol generation failed:', error);
        
        // Show error with retry options
        if (protocolContent) {
            protocolContent.innerHTML = `
                <div class="bg-red-50 border border-red-200 rounded-lg p-6">
                    <div class="flex items-start space-x-3">
                        <div class="text-red-500 text-xl">‚ö†Ô∏è</div>
                        <div class="flex-grow">
                            <h3 class="text-red-800 font-medium mb-2">Protokoll-Generierung fehlgeschlagen</h3>
                            <p class="text-red-700 text-sm mb-3">${error.message}</p>
                            
                            <div class="text-sm text-red-600 space-y-1 mb-4">
                                <p><strong>M√∂gliche L√∂sungen:</strong></p>
                                <ul class="list-disc ml-4 space-y-1">
                                    <li>√úberpr√ºfen Sie, ob Ollama l√§uft: <code class="bg-red-100 px-1 rounded">ollama serve</code></li>
                                    <li>Vergewissern Sie sich, dass das Modell verf√ºgbar ist</li>
                                    <li>Probieren Sie ein anderes Modell aus</li>
                                    <li>Verwenden Sie das Fallback-Protokoll</li>
                                </ul>
                            </div>
                            
                            <div class="flex space-x-3">
                                <button 
                                    onclick="generateProtocol()" 
                                    class="bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded-lg text-sm font-medium transition-colors">
                                    üîÑ Erneut versuchen
                                </button>
                                <button 
                                    onclick="generateFallbackProtocolOnly()" 
                                    class="bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded-lg text-sm font-medium transition-colors">
                                    üìù Fallback-Protokoll
                                </button>
                                <button 
                                    onclick="loadOllamaModels()" 
                                    class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg text-sm font-medium transition-colors">
                                    üîÑ Modelle neu laden
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }
        
    } finally {
        // Re-enable button
        if (protocolBtn) {
            protocolBtn.disabled = false;
            protocolBtn.innerHTML = 'ü§ñ Protokoll generieren';
        }
    }
}

// Display generated protocol with enhanced UI
function displayGeneratedProtocol(result) {
    const protocolContent = document.getElementById('protocolContent');
    
    if (!protocolContent) return;
    
    const modelUsed = result.model_used || 'Unbekannt';
    const method = result.method || 'unknown';
    const generationTime = result.generation_time ? new Date(result.generation_time).toLocaleString('de-DE') : 'Unbekannt';
    
    protocolContent.innerHTML = `
        <div class="bg-green-50 border border-green-200 rounded-lg p-4 mb-6">
            <div class="flex items-center justify-between mb-2">
                <h3 class="text-green-800 font-semibold flex items-center">
                    <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                    </svg>
                    Meeting-Protokoll erfolgreich generiert
                </h3>
                <div class="flex space-x-2">
                    <button 
                        onclick="copyProtocolToClipboard()" 
                        class="bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded text-sm font-medium transition-colors flex items-center space-x-1">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                        </svg>
                        <span>Kopieren</span>
                    </button>
                    <button 
                        onclick="downloadProtocolAsFile()" 
                        class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded text-sm font-medium transition-colors flex items-center space-x-1">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                        </svg>
                        <span>Download</span>
                    </button>
                </div>
            </div>
            <div class="text-green-700 text-sm grid grid-cols-2 md:grid-cols-4 gap-4">
                <div><strong>Methode:</strong> ${method === 'ollama' ? 'ü§ñ KI-generiert' : 'üìù Fallback'}</div>
                <div><strong>Modell:</strong> ${modelUsed}</div>
                <div><strong>Erstellt:</strong> ${generationTime}</div>
                <div><strong>Sprecher:</strong> ${result.speakers?.length || 0}</div>
            </div>
        </div>
        
        <div class="bg-white rounded-lg border">
            <div class="p-4 border-b bg-gray-50">
                <h4 class="font-medium text-gray-800">üìã Generiertes Protokoll</h4>
            </div>
            <div class="p-6">
                <pre id="protocolText" class="whitespace-pre-wrap text-sm font-mono bg-gray-50 p-4 rounded border overflow-auto max-h-96 leading-relaxed">${result.protocol}</pre>
            </div>
        </div>
        
        <div class="mt-4 p-4 bg-blue-50 border border-blue-200 rounded-lg">
            <h4 class="font-medium text-blue-800 mb-2">üîÑ Weitere Optionen</h4>
            <div class="flex flex-wrap gap-2">
                <button 
                    onclick="generateProtocolWithDifferentModel()" 
                    class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-2 rounded text-sm font-medium transition-colors">
                    üîÑ Mit anderem Modell generieren
                </button>
                <button 
                    onclick="generateFallbackProtocolOnly()" 
                    class="bg-gray-600 hover:bg-gray-700 text-white px-3 py-2 rounded text-sm font-medium transition-colors">
                    üìù Einfaches Protokoll anzeigen
                </button>
                <button 
                    onclick="editSpeakerNames()" 
                    class="bg-yellow-600 hover:bg-yellow-700 text-white px-3 py-2 rounded text-sm font-medium transition-colors">
                    ‚úèÔ∏è Sprecher-Namen bearbeiten
                </button>
            </div>
        </div>
    `;
    
    // Scroll to protocol
    protocolContent.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
}

// Generate protocol with different model (allows comparison)
function generateProtocolWithDifferentModel() {
    // Show model selection and regenerate
    const currentModel = selectedProtocolModel;
    
    if (confirm(`M√∂chten Sie das Protokoll mit einem anderen Modell generieren?\n\nAktuell: ${currentModel}\n\nDas aktuelle Protokoll bleibt erhalten.`)) {
        // Could open a modal with model selection or just regenerate with current selection
        generateProtocol();
    }
}

// Generate fallback protocol only
function generateFallbackProtocolOnly() {
    const protocolContent = document.getElementById('protocolContent');
    if (!protocolContent || !currentTranscriptData) return;
    
    const fallbackProtocol = generateSimpleFallbackProtocol();
    
    const result = {
        protocol: fallbackProtocol,
        method: 'fallback',
        model_used: 'Einfache Struktur',
        speakers: Object.keys(speakerNames).map(key => ({ name: speakerNames[key] })),
        generation_time: new Date().toISOString()
    };
    
    displayGeneratedProtocol(result);
}

// Edit speaker names (go back to configuration)
function editSpeakerNames() {
    const speakerNamesSection = document.getElementById('speakerNamesSection');
    if (speakerNamesSection) {
        speakerNamesSection.scrollIntoView({ behavior: 'smooth' });
        
        // Highlight the section briefly
        speakerNamesSection.style.background = '#fef3c7';
        setTimeout(() => {
            speakerNamesSection.style.background = '';
        }, 2000);
    }
}

// Prompt generation and display
async function getStructuredProtocolPrompt() {
    console.log('üéØ Get Structured Protocol Prompt clicked!');
    
    if (!currentTranscriptData) {
        alert('Keine Transkriptionsdaten verf√ºgbar.');
        return;
    }
    
    try {
        // Prepare transcript with real names
        const processedTranscript = processTranscriptWithNames();
        const processedSpeakers = createSpeakerList();
        
        console.log('üìù Generating structured prompt...');
        
        const requestData = {
            transcript: processedTranscript,
            speakers: processedSpeakers
        };
        
        const response = await fetch('/api/v1/protocol/prompt', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(requestData)
        });
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const result = await response.json();
        console.log('‚úÖ Structured prompt generated:', result);
        
        // Display prompt in a modal or copy to clipboard
        if (result.success && result.prompt) {
            displayStructuredPrompt(result);
        } else {
            throw new Error(result.error || 'Prompt-Generierung fehlgeschlagen');
        }
        
    } catch (error) {
        console.error('‚ùå Prompt generation failed:', error);
        alert(`Prompt-Generierung fehlgeschlagen: ${error.message}`);
    }
}

function displayStructuredPrompt(result) {
    const promptData = result.prompt;
    const usageExample = result.usage_example;
    
    // Create modal with structured prompt
    const modal = document.createElement('div');
    modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
    modal.innerHTML = `
        <div class="bg-white rounded-lg max-w-4xl w-full mx-4 max-h-[90vh] overflow-y-auto">
            <div class="p-6">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-lg font-semibold text-gray-800">üìù Strukturierter 9-Punkte-Protokoll Prompt</h3>
                    <button onclick="this.closest('.fixed').remove()" class="text-gray-400 hover:text-gray-600">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
                
                <div class="space-y-4">
                    <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                        <h4 class="font-medium text-blue-800 mb-2">üìä Prompt-Informationen</h4>
                        <div class="grid grid-cols-2 gap-4 text-sm">
                            <div>
                                <span class="font-medium text-blue-700">Format:</span> ${promptData.format}
                            </div>
                            <div>
                                <span class="font-medium text-blue-700">Sprecher:</span> ${promptData.speaker_count}
                            </div>
                            <div>
                                <span class="font-medium text-blue-700">Transkript-L√§nge:</span> ${promptData.transcript_length} Zeichen
                            </div>
                            <div>
                                <span class="font-medium text-blue-700">Erwartete Sektionen:</span> ${promptData.expected_sections.length}
                            </div>
                        </div>
                    </div>
                    
                    <div class="bg-gray-50 border border-gray-200 rounded-lg p-4">
                        <h4 class="font-medium text-gray-800 mb-2">üéØ Strukturierter Prompt</h4>
                        <div class="bg-white border rounded p-3 text-sm font-mono whitespace-pre-wrap max-h-60 overflow-y-auto">
${promptData.content}
                        </div>
                        <div class="mt-2 flex space-x-2">
                            <button onclick="copyToClipboard('${promptData.content.replace(/'/g, "\\'")}', 'Prompt kopiert!')" 
                                    class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded text-sm">
                                üìã Prompt kopieren
                            </button>
                        </div>
                    </div>
                    
                    <div class="bg-green-50 border border-green-200 rounded-lg p-4">
                        <h4 class="font-medium text-green-800 mb-2">üí° Verwendungsbeispiel</h4>
                        <p class="text-sm text-green-700 mb-2">${usageExample.description}</p>
                        <div class="bg-white border rounded p-3 text-sm font-mono">
                            <pre class="whitespace-pre-wrap">${JSON.stringify(usageExample.api_call_example, null, 2)}</pre>
                        </div>
                        <div class="mt-2">
                            <button onclick="copyToClipboard('${JSON.stringify(usageExample.api_call_example, null, 2).replace(/'/g, "\\'")}', 'API-Beispiel kopiert!')" 
                                    class="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded text-sm">
                                üìã API-Beispiel kopieren
                            </button>
                        </div>
                    </div>
                    
                    <div class="bg-yellow-50 border border-yellow-200 rounded-lg p-4">
                        <h4 class="font-medium text-yellow-800 mb-2">üîß Erwartete Protokoll-Struktur</h4>
                        <div class="text-sm text-yellow-700 space-y-1">
                            ${promptData.expected_sections.map((section, i) => `
                                <div class="flex items-center space-x-2">
                                    <span class="font-medium">${i + 1}.</span>
                                    <span>${section}</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
                
                <div class="mt-6 text-center">
                    <button onclick="this.closest('.fixed').remove()" 
                            class="bg-gray-500 hover:bg-gray-600 text-white px-6 py-2 rounded">
                        Schlie√üen
                    </button>
                </div>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
}

// Load models overview on page load
async function loadModelsOverview() {
    console.log('üîÑ Loading models overview...');
    const container = document.getElementById('modelsOverviewContent');
    
    try {
        const response = await fetch('/api/v1/models/overview');
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        console.log('üìÑ Models overview data received:', data);
        
        // Generate overview HTML
        const overviewHTML = `
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                <!-- Whisper Model -->
                <div class="bg-gradient-to-r from-blue-50 to-blue-100 border-l-4 border-blue-500 rounded-lg p-4">
                    <div class="flex items-center justify-between mb-3">
                        <h3 class="text-lg font-semibold text-blue-800 flex items-center">
                            üé§ Whisper
                            <span class="ml-2 px-2 py-1 text-xs font-medium rounded-full ${data.models.whisper.status === 'loaded' ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}">
                                ${data.models.whisper.status === 'loaded' ? '‚úÖ Geladen' : '‚ùå Nicht geladen'}
                            </span>
                        </h3>
                    </div>
                    <div class="space-y-2 text-sm">
                        <div><span class="font-medium">Modell:</span> ${data.models.whisper.current_model}</div>
                        <div><span class="font-medium">Gr√∂√üe:</span> ${data.models.whisper.model_info?.size_mb || 'Unbekannt'} MB</div>
                        <div><span class="font-medium">Geschwindigkeit:</span> ${data.models.whisper.model_info?.speed || 'Unbekannt'}</div>
                        <div><span class="font-medium">Device:</span> ${data.models.whisper.device || 'CPU'}</div>
                        <div class="pt-2">
                            <span class="text-xs text-blue-600 bg-blue-50 px-2 py-1 rounded">
                                ${Object.keys(data.models.whisper.available_models || {}).length} Modelle verf√ºgbar
                            </span>
                        </div>
                    </div>
                </div>
                
                <!-- PyAnnote Model -->
                <div class="bg-gradient-to-r from-green-50 to-green-100 border-l-4 border-green-500 rounded-lg p-4">
                    <div class="flex items-center justify-between mb-3">
                        <h3 class="text-lg font-semibold text-green-800 flex items-center">
                            üë• PyAnnote
                            <span class="ml-2 px-2 py-1 text-xs font-medium rounded-full ${data.models.pyannote.status === 'loaded' ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}">
                                ${data.models.pyannote.status === 'loaded' ? '‚úÖ Geladen' : '‚ùå Nicht geladen'}
                            </span>
                        </h3>
                    </div>
                    <div class="space-y-2 text-sm">
                        <div><span class="font-medium">Modell:</span> speaker-diarization-3.1</div>
                        <div><span class="font-medium">HF Token:</span> ${data.models.pyannote.auth_token === 'configured' ? '‚úÖ Konfiguriert' : '‚ùå Nicht konfiguriert'}</div>
                        <div><span class="font-medium">Features:</span></div>
                        <div class="ml-4 space-y-1">
                            ${data.models.pyannote.capabilities?.map(cap => 
                                `<div class="text-xs text-green-600 bg-green-50 px-2 py-1 rounded inline-block mr-1 mb-1">
                                    ${cap === 'speaker_diarization' ? 'üéØ Speaker-Erkennung' : 
                                      cap === 'voice_activity_detection' ? 'üîä Sprach-Erkennung' : cap}
                                </div>`
                            ).join('') || '<div class="text-xs text-gray-500">Keine Features verf√ºgbar</div>'}
                        </div>
                    </div>
                </div>
                
                <!-- Ollama Model -->
                <div class="bg-gradient-to-r from-purple-50 to-purple-100 border-l-4 border-purple-500 rounded-lg p-4">
                    <div class="flex items-center justify-between mb-3">
                        <h3 class="text-lg font-semibold text-purple-800 flex items-center">
                            ü¶ô Ollama
                            <span class="ml-2 px-2 py-1 text-xs font-medium rounded-full ${data.models.ollama.status === 'available' ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}">
                                ${data.models.ollama.status === 'available' ? '‚úÖ Verf√ºgbar' : '‚ùå Nicht verf√ºgbar'}
                            </span>
                        </h3>
                    </div>
                    <div class="space-y-2 text-sm">
                        <div><span class="font-medium">Server:</span> ${data.models.ollama.base_url}</div>
                        <div><span class="font-medium">Standard:</span> ${data.models.ollama.default_model}</div>
                        <div><span class="font-medium">Version:</span> ${data.models.ollama.server_version || 'Unbekannt'}</div>
                        <div><span class="font-medium">Modelle:</span> ${data.models.ollama.available_models?.length || 0} geladen</div>
                        ${data.models.ollama.available_models?.length > 0 ? `
                            <div class="pt-2 max-h-24 overflow-y-auto">
                                ${data.models.ollama.available_models.slice(0, 3).map(model => 
                                    `<div class="text-xs text-purple-600 bg-purple-50 px-2 py-1 rounded mb-1 truncate">
                                        ${model.name} (${model.size_formatted})
                                    </div>`
                                ).join('')}
                                ${data.models.ollama.available_models.length > 3 ? 
                                    `<div class="text-xs text-purple-500">... und ${data.models.ollama.available_models.length - 3} weitere</div>` : ''
                                }
                            </div>
                        ` : ''}
                    </div>
                </div>
            </div>
            
            <!-- Service Information -->
            <div class="mt-6 bg-gray-50 rounded-lg p-4">
                <h4 class="text-md font-semibold text-gray-800 mb-3 flex items-center">
                    ‚öôÔ∏è Service-Konfiguration
                </h4>
                <div class="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
                    <div>
                        <span class="font-medium text-gray-600">Sprache:</span>
                        <div class="text-gray-800">${data.configuration?.language || 'de'}</div>
                    </div>
                    <div>
                        <span class="font-medium text-gray-600">Status:</span>
                        <div class="text-green-600 font-medium">${data.service_status || 'unbekannt'}</div>
                    </div>
                    <div>
                        <span class="font-medium text-gray-600">Speicher (Whisper):</span>
                        <div class="text-gray-800">${data.memory_usage?.estimated_whisper_size || 'Unbekannt'}</div>
                    </div>
                    <div>
                        <span class="font-medium text-gray-600">Letztes Update:</span>
                        <div class="text-gray-800">${new Date(data.timestamp).toLocaleTimeString('de-DE')}</div>
                    </div>
                </div>
                
                <div class="mt-3 pt-3 border-t border-gray-200">
                    <span class="font-medium text-gray-600">Unterst√ºtzte Audio-Formate:</span>
                    <div class="mt-1 flex flex-wrap gap-1">
                        ${data.configuration?.audio_formats?.map(format => 
                            `<span class="text-xs bg-gray-200 text-gray-700 px-2 py-1 rounded">${format.toUpperCase()}</span>`
                        ).join('') || '<span class="text-xs text-gray-500">Keine Formate gefunden</span>'}
                    </div>
                </div>
            </div>
        `;
        
        container.innerHTML = overviewHTML;
        console.log('‚úÖ Models overview loaded successfully');
        
    } catch (error) {
        console.error('‚ùå Failed to load models overview:', error);
        container.innerHTML = `
            <div class="bg-red-50 border border-red-200 rounded-lg p-4">
                <div class="flex items-center">
                    <svg class="w-5 h-5 text-red-500 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                    </svg>
                    <div>
                        <h3 class="text-red-800 font-medium">Fehler beim Laden der Modell-√úbersicht</h3>
                        <p class="text-red-600 text-sm mt-1">${error.message}</p>
                    </div>
                </div>
                <button onclick="loadModelsOverview()" class="mt-3 text-red-600 hover:text-red-800 text-sm underline">
                    üîÑ Erneut versuchen
                </button>
            </div>
        `;
    }
}

    </script>
    
    <!-- Models Overview Module -->
    <script src="/web/js/models-overview.js"></script>
    
</body>
</html>