<!-- web/index.html -->
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A2T DreamMall - Meeting Protocol Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        .speaker-0 { color: #3B82F6; } /* Blue */
        .speaker-1 { color: #EF4444; } /* Red */
        .speaker-2 { color: #10B981; } /* Green */
        .speaker-3 { color: #F59E0B; } /* Amber */
        .speaker-4 { color: #8B5CF6; } /* Purple */
        .speaker-5 { color: #EC4899; } /* Pink */
        .speaker-unknown { color: #6B7280; } /* Gray */
        
        .transcript-segment {
            padding: 8px 12px;
            margin: 4px 0;
            border-left: 4px solid;
            background: #F9FAFB;
            border-radius: 0 8px 8px 0;
        }
        
        .timestamp {
            font-size: 0.75rem;
            opacity: 0.7;
            font-family: monospace;
        }
        
        .speaker-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
            margin-right: 8px;
        }
        
        .loading-spinner {
            border: 3px solid #f3f4f6;
            border-top: 3px solid #3B82F6;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen">
    <!-- Header -->
    <header class="bg-white shadow-sm border-b">
        <div class="container mx-auto px-6 py-4">
            <div class="flex items-center justify-between">
                <div>
                    <h1 class="text-2xl font-bold text-gray-800">A2T DreamMall</h1>
                    <p class="text-sm text-gray-600">Audio-zu-Text Meeting Protocol Generator</p>
                </div>
                <div class="text-sm text-gray-500">
                    v1.0.0 | KI-gest√ºtzt
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="container mx-auto px-6 py-8">
        
        <!-- Upload Section -->
        <div class="bg-white rounded-lg shadow-sm border p-6 mb-8">
            <h2 class="text-xl font-semibold mb-4 flex items-center">
                <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
                </svg>
                Audio-Datei hochladen
            </h2>
            
            <!-- Model Selection -->
            <div class="mb-4">
                <label for="modelSelect" class="block text-sm font-medium text-gray-700 mb-2">
                    Whisper Modell w√§hlen
                </label>
                <select id="modelSelect" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                    <option value="tiny">Tiny (39 MB) - Schnellstes Modell</option>
                    <option value="base">Base (74 MB) - Ausgewogen</option>
                    <option value="small" selected>Small (244 MB) - Empfohlen (Standard)</option>
                    <option value="medium">Medium (769 MB) - Hohe Qualit√§t</option>
                    <option value="large">Large (1550 MB) - Beste Qualit√§t</option>
                    <option value="large-v2">Large-v2 (1550 MB) - Verbesserte Version</option>
                    <option value="large-v3">Large-v3 (1550 MB) - Neueste Version</option>
                </select>
                <p class="text-sm text-gray-500 mt-1">
                    <span id="modelDescription">Ausgewogen zwischen Geschwindigkeit und Qualit√§t</span>
                </p>
            </div>
            
            <!-- Current Model Display -->
            <div class="mb-4 p-3 bg-blue-50 rounded-lg">
                <div class="flex items-center justify-between">
                    <div>
                        <span class="text-sm font-medium text-blue-800">Aktuelles Modell:</span>
                        <span id="currentModel" class="text-sm text-blue-600 ml-2">Loading...</span>
                    </div>
                    <button id="refreshModels" class="text-blue-600 hover:text-blue-800 text-sm">
                        üîÑ Aktualisieren
                    </button>
                </div>
            </div>
            
            <!-- File Upload -->
            <div class="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center hover:border-gray-400 transition-colors">
                <input type="file" id="audioFile" accept=".mp3,.wav,.m4a,.mp4,.webm,.ogg" class="hidden">
                <label for="audioFile" class="cursor-pointer">
                    <svg class="mx-auto h-12 w-12 text-gray-400" stroke="currentColor" fill="none" viewBox="0 0 48 48">
                        <path d="M28 8H12a4 4 0 00-4 4v20m32-12v8m0 0v8a4 4 0 01-4 4H12a4 4 0 01-4-4v-4m32-4l-3.172-3.172a4 4 0 00-5.656 0L28 28M8 32l9.172-9.172a4 4 0 015.656 0L28 28m0 0l4 4m4-24h8m-4-4v8m-12 4h.02" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                    <p class="mt-2 text-sm text-gray-600">
                        <span class="font-medium text-blue-600 hover:text-blue-500">Datei ausw√§hlen</span>
                        oder hier hineinziehen
                    </p>
                    <p class="text-xs text-gray-500 mt-1">
                        Unterst√ºtzte Formate: MP3, WAV, M4A, MP4, WebM, OGG
                    </p>
                </label>
            </div>
            
            <button id="processBtn" 
                    class="w-full mt-4 bg-blue-600 text-white py-3 px-4 rounded-lg hover:bg-blue-700 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed" 
                    disabled>
                Verarbeiten
            </button>
            
            <!-- File Info Section -->
            <div id="fileInfo" class="mt-4" style="display: none;">
                <!-- File information will be displayed here -->
            </div>
        </div>

        <!-- Status Section -->
        <div id="statusSection" class="hidden bg-white rounded-lg shadow-sm border p-6 mb-8">
            <div class="flex items-center space-x-4">
                <div class="loading-spinner"></div>
                <div>
                    <div id="statusText" class="font-medium text-gray-800"></div>
                    <div id="progressText" class="text-sm text-gray-600"></div>
                </div>
            </div>
            <div class="mt-4">
                <div class="bg-gray-200 rounded-full h-2">
                    <div id="progressBar" class="bg-blue-600 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
                </div>
            </div>
        </div>

        <!-- Results Section -->
        <div id="resultsSection" class="hidden">
            
            <!-- Analysis Overview -->
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
                <div class="bg-white rounded-lg shadow-sm border p-6">
                    <h3 class="text-sm font-medium text-gray-600 mb-2">Dauer</h3>
                    <div id="durationDisplay" class="text-2xl font-bold text-gray-800">--:--</div>
                </div>
                <div class="bg-white rounded-lg shadow-sm border p-6">
                    <h3 class="text-sm font-medium text-gray-600 mb-2">Sprecher</h3>
                    <div id="speakerCount" class="text-2xl font-bold text-gray-800">-</div>
                </div>
                <div class="bg-white rounded-lg shadow-sm border p-6">
                    <h3 class="text-sm font-medium text-gray-600 mb-2">Sprache</h3>
                    <div id="languageDisplay" class="text-2xl font-bold text-gray-800">-</div>
                </div>
            </div>

            <!-- Speaker Name Configuration -->
            <div id="speakerNamesSection" class="hidden bg-white rounded-lg shadow-sm border mb-8">
                <div class="p-6 border-b">
                    <h2 class="text-lg font-semibold">Sprecher-Namen konfigurieren</h2>
                    <p class="text-sm text-gray-600 mt-1">
                        Geben Sie f√ºr jeden erkannten Sprecher einen Namen ein, bevor Sie das Meeting-Protokoll generieren.
                    </p>
                </div>
                <div id="speakerNamesContent" class="p-6">
                    <!-- Speaker name inputs will be inserted here -->
                </div>
            </div>

            <!-- Transcript Section -->
            <div class="bg-white rounded-lg shadow-sm border mb-8">
                <div class="p-6 border-b">
                    <div class="flex items-center justify-between">
                        <h2 class="text-lg font-semibold">Transkript mit Speaker-Erkennung</h2>
                        <div class="flex items-center space-x-4">
                            <div id="speakerLegend" class="flex items-center space-x-3 text-sm"></div>
                            <button onclick="toggleTimestamps()" id="timestampToggle"
                                    class="text-sm text-gray-600 hover:text-gray-800">
                                Zeitstempel anzeigen
                            </button>
                        </div>
                    </div>
                </div>
                <div id="transcriptContent" class="p-6 max-h-96 overflow-y-auto">
                    <!-- Transcript segments will be inserted here -->
                </div>
            </div>

            <!-- Protocol Generation -->
            <div id="protocolSection" class="hidden bg-white rounded-lg shadow-sm border">
                <div class="p-6 border-b">
                    <div class="flex items-center justify-between">
                        <h2 class="text-lg font-semibold">KI-Meeting-Protokoll</h2>
                        <div class="flex items-center space-x-4">
                            <!-- Model Selection for Protocol -->
                            <div class="flex items-center space-x-2">
                                <label for="protocolModelSelect" class="text-sm font-medium text-gray-700">
                                    LLM-Modell:
                                </label>
                                <select id="protocolModelSelect" class="px-3 py-2 border border-gray-300 rounded-lg text-sm focus:ring-2 focus:ring-green-500 focus:border-transparent">
                                    <option value="">Lade Modelle...</option>
                                </select>
                            </div>
                            <button onclick="generateProtocol()" id="protocolBtn"
                                    class="bg-green-600 hover:bg-green-700 text-white px-6 py-3 rounded-lg font-medium transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed"
                                    disabled>
                                ü§ñ Protokoll generieren
                            </button>
                            <button onclick="getStructuredProtocolPrompt()" id="promptBtn"
                                    class="bg-blue-600 hover:bg-blue-700 text-white px-6 py-3 rounded-lg font-medium transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed"
                                    disabled>
                                üìù Strukturierter Prompt
                            </button>
                        </div>
                    </div>
                    <p class="text-sm text-gray-600 mt-2">
                        Das KI-Protokoll wird mit den angegebenen Sprecher-Namen und dem gew√§hlten LLM-Modell erstellt.
                        <br>
                        <span class="text-blue-600">üìù Der "Strukturierte Prompt" kann f√ºr externe LLM-Tools kopiert werden.</span>
                    </p>
                    <div id="modelInfo" class="mt-2 p-3 bg-blue-50 rounded-lg text-sm text-blue-700" style="display: none;">
                        <!-- Model information will be displayed here -->
                    </div>
                </div>
                <div id="protocolContent" class="p-6">
                    <div class="text-gray-500 text-center py-8">
                        Konfigurieren Sie zuerst die Sprecher-Namen, dann klicken Sie auf "Protokoll generieren".
                    </div>
                </div>
            </div>
        </div>
    </main>

    <script>
let currentJobId = null;
let pollInterval = null;

// Model descriptions
const modelDescriptions = {
    "tiny": "Schnellstes Modell, geringste Qualit√§t (~32x schneller)",
    "base": "Ausgewogen zwischen Geschwindigkeit und Qualit√§t (~16x schneller)", 
    "small": "Gute Qualit√§t, moderate Geschwindigkeit (~6x schneller)",
    "medium": "Hohe Qualit√§t, langsamer (~2x schneller)",
    "large": "Beste Qualit√§t, langsamste Verarbeitung (1x)",
    "large-v2": "Verbesserte Version von Large (1x)",
    "large-v3": "Neueste Version mit bester Qualit√§t (1x)"
};

// Load available models on page load
async function loadAvailableModels() {
    console.log('üîÑ Loading available models...');
    try {
        console.log('üì° Fetching from /api/v1/models...');
        const response = await fetch('/api/v1/models');
        console.log('üì° Response status:', response.status);
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        console.log('üìÑ Models data received:', data);
        
        // Update current model display
        const currentModelSpan = document.getElementById('currentModel');
        if (currentModelSpan) {
            currentModelSpan.textContent = data.current_model || 'base';
            console.log('‚úÖ Current model updated:', data.current_model);
        }
        
        // Update model select options
        const select = document.getElementById('modelSelect');
        if (select && data.available_models) {
            select.innerHTML = '';
            
            Object.entries(data.available_models).forEach(([model, info]) => {
                const option = document.createElement('option');
                option.value = model;
                option.textContent = `${model.charAt(0).toUpperCase() + model.slice(1)} (${info.size}) - ${info.description}`;
                if (model === data.current_model) {
                    option.selected = true;
                }
                select.appendChild(option);
            });
            
            console.log(`‚úÖ Model select updated with ${Object.keys(data.available_models).length} options`);
            
            // Update description for initially selected model
            updateModelDescription();
        }
        
    } catch (error) {
        console.error('‚ùå Failed to load models:', error);
        
        // Fallback: Set up basic model options
        const currentModelSpan = document.getElementById('currentModel');
        if (currentModelSpan) {
            currentModelSpan.textContent = 'base (offline)';
        }
        
        const select = document.getElementById('modelSelect');
        if (select) {
            select.innerHTML = `
                <option value="tiny">Tiny (39 MB) - Schnellstes Modell</option>
                <option value="base">Base (74 MB) - Ausgewogen</option>
                <option value="small" selected>Small (244 MB) - Empfohlen (Standard)</option>
                <option value="medium">Medium (769 MB) - Hohe Qualit√§t</option>
                <option value="large">Large (1550 MB) - Beste Qualit√§t</option>
                <option value="large-v2">Large-v2 (1550 MB) - Verbesserte Version</option>
                <option value="large-v3">Large-v3 (1550 MB) - Neueste Version</option>
            `;
            console.log('‚úÖ Fallback model options set');
        }
    }
}

// Update description when model changes
function updateModelDescription() {
    const select = document.getElementById('modelSelect');
    const descElement = document.getElementById('modelDescription');
    
    if (select && descElement) {
        const selectedModel = select.value;
        const description = modelDescriptions[selectedModel] || 'Keine Beschreibung verf√ºgbar';
        descElement.textContent = description;
    }
}

// Enhanced file selection with validation
function handleFileSelect(event) {
    console.log('üéØ handleFileSelect called');
    
    const audioFile = document.getElementById('audioFile');
    const processBtn = document.getElementById('processBtn');
    const fileInfo = document.getElementById('fileInfo');
    
    console.log('üìã Elements found:', {
        audioFile: !!audioFile,
        processBtn: !!processBtn,
        fileInfo: !!fileInfo,
        filesCount: audioFile ? audioFile.files.length : 0
    });
    
    if (!audioFile || !audioFile.files.length) {
        console.log('‚ùå No file selected');
        if (processBtn) {
            processBtn.disabled = true;
            processBtn.textContent = 'Verarbeiten';
        }
        if (fileInfo) fileInfo.style.display = 'none';
        return;
    }
    
    const file = audioFile.files[0];
    console.log('üìÑ File selected:', {
        name: file.name,
        type: file.type,
        size: `${(file.size / 1024 / 1024).toFixed(2)} MB`
    });
    
    // Validate file
    const validation = validateAudioFile(file);
    
    if (!validation.valid) {
        console.error('‚ùå File validation failed:', validation.error);
        showFileError(validation.error);
        if (processBtn) processBtn.disabled = true;
        return;
    }
    
    // Show file info
    if (fileInfo) {
        const durationEstimate = estimateProcessingTime(file.size);
        
        fileInfo.innerHTML = `
            <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                <div class="flex items-start space-x-3">
                    <div class="text-blue-500 text-xl">üìÅ</div>
                    <div class="flex-grow">
                        <h4 class="text-blue-800 font-medium">${file.name}</h4>
                        <div class="text-blue-600 text-sm mt-1 space-y-1">
                            <div>Gr√∂√üe: ${(file.size / 1024 / 1024).toFixed(2)} MB</div>
                            <div>Typ: ${file.type || 'Unbekannt'}</div>
                            <div>Gesch√§tzte Verarbeitungszeit: ${durationEstimate}</div>
                        </div>
                        ${file.size > 50 * 1024 * 1024 ? `
                            <div class="mt-2 text-amber-600 text-sm">
                                ‚ö†Ô∏è Gro√üe Datei - Verarbeitung kann l√§nger dauern
                            </div>
                        ` : ''}
                    </div>
                </div>
            </div>
        `;
        fileInfo.style.display = 'block';
    }
    
    // Enable process button
    if (processBtn) {
        processBtn.disabled = false;
        processBtn.innerHTML = `
            <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
            </svg>
            Verarbeitung starten
        `;
    }
}

// Validate audio file
function validateAudioFile(file) {
    const maxSize = 100 * 1024 * 1024; // 100 MB
    const allowedTypes = [
        'audio/mpeg', 'audio/mp3', 'audio/wav', 'audio/wave', 'audio/x-wav',
        'audio/mp4', 'audio/m4a', 'audio/aac', 'audio/ogg', 'audio/webm',
        'audio/flac', 'audio/x-flac'
    ];
    
    const allowedExtensions = [
        '.mp3', '.wav', '.m4a', '.aac', '.ogg', '.webm', '.flac', '.mp4'
    ];
    
    // Check file size
    if (file.size > maxSize) {
        return {
            valid: false,
            error: `Datei zu gro√ü (${(file.size / 1024 / 1024).toFixed(2)} MB). Maximum: 100 MB`
        };
    }
    
    // Check file type and extension
    const fileName = file.name.toLowerCase();
    const hasValidExtension = allowedExtensions.some(ext => fileName.endsWith(ext));
    const hasValidType = allowedTypes.includes(file.type);
    
    if (!hasValidExtension && !hasValidType) {
        return {
            valid: false,
            error: `Ung√ºltiger Dateityp. Unterst√ºtzt: ${allowedExtensions.join(', ')}`
        };
    }
    
    // Check if file is empty
    if (file.size === 0) {
        return {
            valid: false,
            error: 'Datei ist leer'
        };
    }
    
    return { valid: true };
}

// Estimate processing time based on file size
function estimateProcessingTime(fileSize) {
    const sizeMB = fileSize / 1024 / 1024;
    
    if (sizeMB < 5) return '1-2 Minuten';
    if (sizeMB < 20) return '2-5 Minuten';
    if (sizeMB < 50) return '5-10 Minuten';
    return '10+ Minuten';
}

// Show file error
function showFileError(message) {
    const fileInfo = document.getElementById('fileInfo');
    if (fileInfo) {
        fileInfo.innerHTML = `
            <div class="bg-red-50 border border-red-200 rounded-lg p-4">
                <div class="flex items-start space-x-3">
                    <div class="text-red-500 text-xl">‚ùå</div>
                    <div>
                        <h4 class="text-red-800 font-medium">Ung√ºltige Datei</h4>
                        <p class="text-red-600 text-sm mt-1">${message}</p>
                        <div class="mt-2 text-red-600 text-xs">
                            <p><strong>Unterst√ºtzte Formate:</strong> MP3, WAV, M4A, AAC, OGG, FLAC</p>
                            <p><strong>Maximale Gr√∂√üe:</strong> 100 MB</p>
                        </div>
                    </div>
                </div>
            </div>
        `;
        fileInfo.style.display = 'block';
    }
}

// Upload and process audio
async function uploadAudio() {
    console.log('üéØ Upload button clicked!');
    
    const fileInput = document.getElementById('audioFile');
    const modelSelect = document.getElementById('modelSelect');
    const processBtn = document.getElementById('processBtn');
    
    const file = fileInput ? fileInput.files[0] : null;
    
    if (!file) {
        alert('Bitte w√§hlen Sie eine Audio-Datei aus.');
        return;
    }
    
    // Validate file again before upload
    const validation = validateAudioFile(file);
    if (!validation.valid) {
        showFileError(validation.error);
        return;
    }
    
    const selectedModel = modelSelect ? modelSelect.value : 'small';
    console.log('üéØ Selected model:', selectedModel);
    
    // Disable button and show processing status
    if (processBtn) {
        processBtn.disabled = true;
        processBtn.textContent = 'Wird hochgeladen...';
    }
    
    const formData = new FormData();
    formData.append('audio', file);
    formData.append('model', selectedModel);
    
    console.log(`üöÄ Starting upload with model: ${selectedModel}`);
    
    try {
        const response = await fetch('/api/v1/transcribe', {
            method: 'POST',
            body: formData
        });
        
        console.log('üì° Response received:', response.status);
        
        const result = await response.json();
        console.log('üìÑ Response data:', result);
        
        if (response.ok && result.job_id) {
            console.log('‚úÖ Job started with ID:', result.job_id);
            
            // Hide upload section and show processing
            hideUploadSection();
            showProcessingStatus();
            
            // Start polling for results
            pollForResults(result.job_id);
        } else {
            throw new Error(result.error || 'Upload failed');
        }
    } catch (error) {
        console.error('‚ùå Upload error:', error);
        alert(`Fehler beim Upload: ${error.message}`);
        
        // Re-enable button
        if (processBtn) {
            processBtn.disabled = false;
            processBtn.innerHTML = `
                <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                </svg>
                Verarbeitung starten
            `;
        }
    }
}

// Hide upload section during processing
function hideUploadSection() {
    const uploadSection = document.querySelector('.bg-white.rounded-lg.shadow-sm.border.p-6.mb-8');
    if (uploadSection) {
        uploadSection.style.display = 'none';
    }
}

// Show processing status with improved loading states
function showProcessingStatus() {
    const statusSection = document.getElementById('statusSection');
    if (statusSection) {
        statusSection.innerHTML = `
            <div class="text-center">
                <div class="loading-spinner mx-auto mb-4"></div>
                <h3 class="text-lg font-semibold text-blue-800 mb-2">Audio wird verarbeitet...</h3>
                <div id="processingSteps" class="space-y-2 text-left max-w-md mx-auto">
                    <div id="step-upload" class="flex items-center space-x-2">
                        <div class="w-4 h-4 rounded-full bg-green-500"></div>
                        <span class="text-green-700">‚úÖ Upload abgeschlossen</span>
                    </div>
                    <div id="step-convert" class="flex items-center space-x-2">
                        <div class="w-4 h-4 rounded-full bg-blue-500 animate-pulse"></div>
                        <span class="text-blue-700">üîÑ Audio-Konvertierung...</span>
                    </div>
                    <div id="step-transcribe" class="flex items-center space-x-2">
                        <div class="w-4 h-4 rounded-full bg-gray-300"></div>
                        <span class="text-gray-500">‚è≥ Transkription (Whisper)</span>
                    </div>
                    <div id="step-diarization" class="flex items-center space-x-2">
                        <div class="w-4 h-4 rounded-full bg-gray-300"></div>
                        <span class="text-gray-500">‚è≥ Sprecher-Erkennung (PyAnnote)</span>
                    </div>
                </div>
                <div class="mt-4 text-sm text-gray-600">
                    <p>‚è±Ô∏è Dies kann je nach Datei-Gr√∂√üe einige Minuten dauern</p>
                    <div class="mt-2 text-xs text-gray-500">
                        <div id="processingTip">üí° Tipp: Kleinere Modelle (tiny/base) sind schneller</div>
                    </div>
                </div>
            </div>
        `;
        statusSection.classList.remove('hidden');
        statusSection.style.display = 'block';
    }
}

// Update processing step status
function updateProcessingStep(step, status, message) {
    const stepElement = document.getElementById(`step-${step}`);
    if (!stepElement) return;
    
    const indicator = stepElement.querySelector('.w-4.h-4');
    const text = stepElement.querySelector('span');
    
    if (status === 'active') {
        indicator.className = 'w-4 h-4 rounded-full bg-blue-500 animate-pulse';
        text.className = 'text-blue-700';
        text.textContent = `üîÑ ${message}`;
    } else if (status === 'completed') {
        indicator.className = 'w-4 h-4 rounded-full bg-green-500';
        text.className = 'text-green-700';
        text.textContent = `‚úÖ ${message}`;
    } else if (status === 'error') {
        indicator.className = 'w-4 h-4 rounded-full bg-red-500';
        text.className = 'text-red-700';
        text.textContent = `‚ùå ${message}`;
    }
}

// Enhanced poll for results with step tracking
async function pollForResults(jobId) {
    let attempts = 0;
    const maxAttempts = 120; // 10 minutes timeout
    
    const pollInterval = setInterval(async () => {
        attempts++;
        
        try {
            const response = await fetch(`/api/v1/status/${jobId}`);
            const data = await response.json();
            
            // Update processing steps based on status
            if (data.status === 'processing') {
                if (data.progress >= 25) {
                    updateProcessingStep('convert', 'completed', 'Audio-Konvertierung abgeschlossen');
                    updateProcessingStep('transcribe', 'active', 'Transkription l√§uft...');
                }
                if (data.progress >= 75) {
                    updateProcessingStep('transcribe', 'completed', 'Transkription abgeschlossen');
                    updateProcessingStep('diarization', 'active', 'Sprecher-Erkennung...');
                }
            }
            
            if (data.status === 'completed') {
                clearInterval(pollInterval);
                updateProcessingStep('transcribe', 'completed', 'Transkription abgeschlossen');
                updateProcessingStep('diarization', 'completed', 'Sprecher-Erkennung abgeschlossen');
                
                setTimeout(() => {
                    displayResults(data.result);
                }, 500); // Small delay to show completion
            } else if (data.status === 'failed') {
                clearInterval(pollInterval);
                showError(data.error || 'Processing failed');
            } else if (attempts >= maxAttempts) {
                clearInterval(pollInterval);
                showError('Timeout: Processing took too long');
            }
        } catch (error) {
            console.error('Polling error:', error);
            attempts += 5; // Fast fail on network errors
        }
        
        // Show timeout warning
        if (attempts > 60 && attempts % 20 === 0) {
            const tip = document.getElementById('processingTip');
            if (tip) {
                tip.innerHTML = `‚ö†Ô∏è Verarbeitung dauert lange. Bei gro√üen Dateien kann dies normal sein.`;
                tip.className = 'text-amber-600';
            }
        }
        
    }, 5000); // Poll every 5 seconds
}

// Display results
function displayResults(result) {
    console.log('üéâ Showing results:', result);
    
    // Hide processing status
    const statusSection = document.getElementById('statusSection');
    if (statusSection) {
        statusSection.style.display = 'none';
    }
    
    // Show results section
    const resultsSection = document.getElementById('resultsSection');
    if (resultsSection) {
        resultsSection.classList.remove('hidden');
        resultsSection.style.display = 'block';
    }
    
    // Update metadata displays
    const metadata = result.metadata || {};
    
    const durationDisplay = document.getElementById('durationDisplay');
    if (durationDisplay) {
        durationDisplay.textContent = metadata.duration_formatted || formatTime(metadata.duration || 0);
    }
    
    const speakerCount = document.getElementById('speakerCount');
    if (speakerCount) {
        const speakers = result.segments ? [...new Set(result.segments.map(s => s.speaker))].length : 1;
        speakerCount.textContent = speakers;
    }
    
    const languageDisplay = document.getElementById('languageDisplay');
    if (languageDisplay) {
        languageDisplay.textContent = (metadata.language || 'de').toUpperCase();
    }
    
    // Display transcript with speaker information
    displayTranscript(result);
    
    // Scroll to results
    resultsSection.scrollIntoView({ behavior: 'smooth' });
}

// Show error
function showError(message) {
    const statusSection = document.getElementById('statusSection');
    if (statusSection) {
        statusSection.innerHTML = `
            <div class="text-center">
                <div class="text-red-500 text-6xl mb-4">‚ùå</div>
                <h3 class="text-lg font-semibold text-red-800 mb-2">Fehler bei der Verarbeitung</h3>
                <p class="text-red-600 mb-4">${message}</p>
                <button onclick="resetUpload()" class="bg-blue-600 text-white py-2 px-4 rounded-lg hover:bg-blue-700">
                    Erneut versuchen
                </button>
            </div>
        `;
        statusSection.style.display = 'block';
    }
}

// Display transcript with speakers
let currentTranscriptData = null; // Store transcript data for protocol generation
let speakerNames = {}; // Store speaker name mappings

function displayTranscript(data) {
    const transcriptContent = document.getElementById('transcriptContent');
    
    if (!transcriptContent) return;
    
    // Store data for later use
    currentTranscriptData = data;
    
    let segments = [];
    
    // Use segments if available
    if (data.segments && data.segments.length > 0) {
        segments = data.segments;
    } else {
        // Fallback: create single segment
        segments = [{
            speaker: 'SPEAKER_01',
            text: data.transcript || 'Kein Transkript verf√ºgbar',
            start: 0,
            end: data.metadata?.duration || 0
        }];
    }
    
    // Get unique speakers for color coding
    const speakers = [...new Set(segments.map(s => s.speaker))];
    
    // Handle edge case: no speakers detected
    if (speakers.length === 0) {
        console.warn('‚ö†Ô∏è No speakers detected, creating default speaker');
        speakers.push('SPEAKER_01');
        segments = segments.length > 0 ? segments : [{
            speaker: 'SPEAKER_01',
            text: data.transcript || 'Kein Transkript verf√ºgbar',
            start: 0,
            end: data.metadata?.duration || 0
        }];
    }
    
    // Initialize speaker names with defaults
    speakerNames = {};
    speakers.forEach((speaker, index) => {
        if (speakers.length === 1) {
            speakerNames[speaker] = 'Sprecher';
        } else {
            speakerNames[speaker] = `Person ${index + 1}`;
        }
    });
    
    // Show appropriate UI based on speaker count
    if (speakers.length === 1) {
        // Single speaker - no need for complex name assignment
        displaySingleSpeakerMessage();
    } else {
        // Multiple speakers - show name assignment UI
        displaySpeakerNamesConfig(speakers);
    }
    
    // Create transcript HTML
    transcriptContent.innerHTML = segments.map((segment, index) => {
        const speakerIndex = speakers.indexOf(segment.speaker);
        const speakerColor = getSpeakerColor(speakerIndex);
        
        return `
            <div class="transcript-segment border-l-4 pl-4 py-2" style="border-left-color: ${speakerColor};">
                <div class="flex items-center justify-between mb-1">
                    <span class="speaker-badge px-2 py-1 rounded text-xs font-medium" style="background-color: ${speakerColor}20; color: ${speakerColor};">
                        <span class="speaker-display" data-speaker="${segment.speaker}">${speakerNames[segment.speaker]}</span>
                    </span>
                    <span class="timestamp text-xs text-gray-500">
                        ${formatTime(segment.start)} - ${formatTime(segment.end)}
                    </span>
                </div>
                <div class="text-gray-800">${segment.text}</div>
            </div>
        `;
    }).join('');
    
    // Show speaker legend
    updateSpeakerLegend(speakers);
}

// Display message for single speaker scenarios
function displaySingleSpeakerMessage() {
    const speakerNamesSection = document.getElementById('speakerNamesSection');
    const speakerNamesContent = document.getElementById('speakerNamesContent');
    
    if (!speakerNamesSection || !speakerNamesContent) return;
    
    // Show the section
    speakerNamesSection.classList.remove('hidden');
    
    speakerNamesContent.innerHTML = `
        <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
            <div class="flex items-center space-x-3">
                <div class="text-blue-500 text-xl">üë§</div>
                <div>
                    <h3 class="text-blue-800 font-medium">Ein Sprecher erkannt</h3>
                    <p class="text-blue-600 text-sm mt-1">
                        Es wurde nur ein Sprecher erkannt oder die Sprecher-Erkennung war nicht verf√ºgbar.
                        Das Protokoll wird f√ºr eine Person erstellt.
                    </p>
                </div>
            </div>
            
            <div class="mt-4">
                <label for="single_speaker_name" class="block text-sm font-medium text-gray-700 mb-2">
                    Name f√ºr den Sprecher (optional):
                </label>
                <div class="flex space-x-3">
                    <input 
                        type="text" 
                        id="single_speaker_name" 
                        class="flex-grow px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                        placeholder="z.B. Max Mustermann"
                        value="${Object.values(speakerNames)[0] || 'Sprecher'}"
                        onchange="updateSingleSpeakerName(this.value)"
                    >
                    <button 
                        onclick="confirmSpeakerNames()" 
                        class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg font-medium transition-colors">
                        ‚úÖ Best√§tigen
                    </button>
                </div>
            </div>
        </div>
    `;
}

// Display speaker names configuration
function displaySpeakerNamesConfig(speakers) {
    const speakerNamesSection = document.getElementById('speakerNamesSection');
    const speakerNamesContent = document.getElementById('speakerNamesContent');
    
    if (!speakerNamesSection || !speakerNamesContent) return;
    
    // Show the section
    speakerNamesSection.classList.remove('hidden');
    
    // Create input fields for each speaker
    speakerNamesContent.innerHTML = speakers.map((speaker, index) => {
        const speakerColor = getSpeakerColor(index);
        
        return `
            <div class="mb-4 p-4 border rounded-lg" style="border-left: 4px solid ${speakerColor};">
                <div class="flex items-center space-x-4">
                    <div class="flex-shrink-0">
                        <span class="speaker-badge px-3 py-2 rounded text-sm font-medium" style="background-color: ${speakerColor}20; color: ${speakerColor};">
                            ${speaker}
                        </span>
                    </div>
                    <div class="flex-grow">
                        <label for="name_${speaker}" class="block text-sm font-medium text-gray-700 mb-1">
                            Name f√ºr diesen Sprecher:
                        </label>
                        <input 
                            type="text" 
                            id="name_${speaker}" 
                            data-speaker="${speaker}"
                            class="speaker-name-input w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                            placeholder="z.B. Max Mustermann, Projektleiter, etc."
                            value="${speakerNames[speaker]}"
                            onchange="updateSpeakerName('${speaker}', this.value)"
                        >
                    </div>
                </div>
            </div>
        `;
    }).join('');
    
    // Add confirmation button
    speakerNamesContent.innerHTML += `
        <div class="mt-6 pt-4 border-t">
            <div class="flex justify-between items-center">
                <p class="text-sm text-gray-600">
                    Sprecher-Namen konfiguriert. Sie k√∂nnen das Meeting-Protokoll generieren.
                </p>
                <button 
                    onclick="confirmSpeakerNames()" 
                    class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg font-medium transition-colors">
                    ‚úÖ Namen best√§tigen
                </button>
            </div>
        </div>
    `;
}

// Update single speaker name
function updateSingleSpeakerName(newName) {
    const speakerId = Object.keys(speakerNames)[0];
    if (speakerId) {
        speakerNames[speakerId] = newName || 'Sprecher';
        updateTranscriptSpeakerNames();
        updateSpeakerLegend([speakerId]);
    }
}

// Update speaker name
function updateSpeakerName(speaker, newName) {
    speakerNames[speaker] = newName || `Person ${Object.keys(speakerNames).indexOf(speaker) + 1}`;
    
    // Update transcript display
    updateTranscriptSpeakerNames();
    updateSpeakerLegend(Object.keys(speakerNames));
}

// Update transcript speaker names in real-time
function updateTranscriptSpeakerNames() {
    const speakerDisplays = document.querySelectorAll('.speaker-display');
    speakerDisplays.forEach(display => {
        const speaker = display.getAttribute('data-speaker');
        if (speakerNames[speaker]) {
            display.textContent = speakerNames[speaker];
        }
    });
}

// Update speaker legend
function updateSpeakerLegend(speakers) {
    const speakerLegend = document.getElementById('speakerLegend');
    if (!speakerLegend) return;
    
    speakerLegend.innerHTML = speakers.map((speaker, index) => {
        const speakerColor = getSpeakerColor(index);
        const displayName = speakerNames[speaker] || speaker;
        
        return `
            <span class="flex items-center">
                <span class="w-3 h-3 rounded-full mr-2" style="background-color: ${speakerColor};"></span>
                <span class="text-sm">${displayName}</span>
            </span>
        `;
    }).join('');
}

// Confirm speaker names and enable protocol generation
function confirmSpeakerNames() {
    const protocolSection = document.getElementById('protocolSection');
    const protocolBtn = document.getElementById('protocolBtn');
    
    // Show protocol section
    if (protocolSection) {
        protocolSection.classList.remove('hidden');
    }
    
    // Load Ollama models when protocol section becomes available
    loadOllamaModels();
    
    // Enable protocol buttons
    if (protocolBtn) {
        protocolBtn.disabled = false;
    }
    
    const promptBtn = document.getElementById('promptBtn');
    if (promptBtn) {
        promptBtn.disabled = false;
    }
    
    // Scroll to protocol section
    if (protocolSection) {
        protocolSection.scrollIntoView({ behavior: 'smooth' });
    }
    
    // Show success message
    const speakerNamesContent = document.getElementById('speakerNamesContent');
    if (speakerNamesContent) {
        const successMsg = document.createElement('div');
        successMsg.className = 'mt-4 p-3 bg-green-100 border border-green-400 text-green-700 rounded-lg';
        successMsg.innerHTML = '‚úÖ Sprecher-Namen best√§tigt! Sie k√∂nnen jetzt das Meeting-Protokoll generieren.';
        speakerNamesContent.appendChild(successMsg);
    }
}

// Get speaker color
function getSpeakerColor(index) {
    const colors = [
        '#3B82F6', // Blue
        '#EF4444', // Red  
        '#10B981', // Green
        '#F59E0B', // Amber
        '#8B5CF6', // Purple
        '#EC4899'  // Pink
    ];
    return colors[index % colors.length];
}

// Format time helper
function formatTime(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
}

// Reset upload
function resetUpload() {
    location.reload();
}

// Initialize page with all event handlers
document.addEventListener('DOMContentLoaded', function() {
    console.log('üöÄ Page loaded, initializing...');
    
    // Load available models
    loadAvailableModels();
    loadOllamaModels();
    
    // Set up event handlers
    const audioFile = document.getElementById('audioFile');
    const processBtn = document.getElementById('processBtn');
    const modelSelect = document.getElementById('modelSelect');
    const refreshModels = document.getElementById('refreshModels');
    
    // File selection handler
    if (audioFile) {
        audioFile.addEventListener('change', handleFileSelect);
        console.log('‚úÖ File input event listener added');
    } else {
        console.error('‚ùå Audio file input not found');
    }
    
    // Process button handler  
    if (processBtn) {
        processBtn.addEventListener('click', uploadAudio);
        console.log('‚úÖ Process button event listener added');
    } else {
        console.error('‚ùå Process button not found');
    }
    
    // Model selection handler
    if (modelSelect) {
        modelSelect.addEventListener('change', updateModelDescription);
        console.log('‚úÖ Model select event listener added');
    }
    
    // Refresh models handler
    if (refreshModels) {
        refreshModels.addEventListener('click', loadAvailableModels);
        console.log('‚úÖ Refresh models event listener added');
    }
    
    // Protocol model selection handler
    const protocolModelSelect = document.getElementById('protocolModelSelect');
    if (protocolModelSelect) {
        protocolModelSelect.addEventListener('change', updateProtocolModelInfo);
        console.log('‚úÖ Protocol model select event listener added');
    }
    
    // Add drag and drop support
    setupDragAndDrop();
    
    console.log('‚úÖ All event handlers initialized');
});

// Setup drag and drop
function setupDragAndDrop() {
    const uploadArea = document.querySelector('.border-dashed');
    if (!uploadArea) {
        console.error('‚ùå Upload area not found for drag and drop');
        return;
    }
    
    uploadArea.addEventListener('dragover', function(e) {
        e.preventDefault();
        e.stopPropagation();
        uploadArea.classList.add('border-blue-400', 'bg-blue-50');
    });
    
    uploadArea.addEventListener('dragleave', function(e) {
        e.preventDefault();
        e.stopPropagation();
        uploadArea.classList.remove('border-blue-400', 'bg-blue-50');
    });
    
    uploadArea.addEventListener('drop', function(e) {
        e.preventDefault();
        e.stopPropagation();
        uploadArea.classList.remove('border-blue-400', 'bg-blue-50');
        
        const files = e.dataTransfer.files;
        if (files.length > 0) {
            const audioFile = document.getElementById('audioFile');
            if (audioFile) {
                audioFile.files = files;
                handleFileSelect();
                console.log('‚úÖ File dropped and selected');
            }
        }
    });
    
    console.log('‚úÖ Drag and drop setup completed');
}

// Ollama Models Management
let ollamaModels = [];
let selectedProtocolModel = null;

// Load available Ollama models for protocol generation
async function loadOllamaModels() {
    console.log('ü§ñ Loading available Ollama models...');
    try {
        const response = await fetch('/api/v1/ollama/models');
        const data = await response.json();
        
        console.log('ü§ñ Ollama models response:', data);
        
        const modelSelect = document.getElementById('protocolModelSelect');
        const modelInfo = document.getElementById('modelInfo');
        
        if (!data.available || !data.models || data.models.length === 0) {
            // No Ollama models available
            if (modelSelect) {
                modelSelect.innerHTML = '<option value="">Ollama nicht verf√ºgbar</option>';
                modelSelect.disabled = true;
            }
            
            if (modelInfo) {
                modelInfo.innerHTML = `
                    ‚ö†Ô∏è Ollama-Server nicht verf√ºgbar. Es werden Fallback-Protokolle erstellt.
                    <br><small>Starten Sie Ollama mit "ollama serve" f√ºr erweiterte KI-Protokolle.</small>
                `;
                modelInfo.className = 'mt-2 p-3 bg-yellow-50 rounded-lg text-sm text-yellow-700';
                modelInfo.style.display = 'block';
            }
            
            console.log('‚ö†Ô∏è No Ollama models available');
            return;
        }
        
        // Ollama available - populate models
        ollamaModels = data.models;
        
        if (modelSelect) {
            modelSelect.innerHTML = '';
            
            // Add models to select
            data.models.forEach(model => {
                const option = document.createElement('option');
                option.value = model.name;
                option.textContent = `${model.name} (${model.parameter_size}, ${model.size_formatted})`;
                
                // Mark recommended models
                if (model.recommended) {
                    option.textContent += ' ‚≠ê Empfohlen';
                    option.selected = true;
                    selectedProtocolModel = model.name;
                }
                
                modelSelect.appendChild(option);
            });
            
            // Set default if no recommended model selected
            if (!selectedProtocolModel && data.models.length > 0) {
                selectedProtocolModel = data.models[0].name;
                modelSelect.value = selectedProtocolModel;
            }
            
            modelSelect.disabled = false;
            console.log(`‚úÖ Loaded ${data.models.length} Ollama models`);
            
            // Update model info
            updateProtocolModelInfo();
        }
        
    } catch (error) {
        console.error('‚ùå Failed to load Ollama models:', error);
        
        const modelSelect = document.getElementById('protocolModelSelect');
        const modelInfo = document.getElementById('modelInfo');
        
        if (modelSelect) {
            modelSelect.innerHTML = '<option value="">Fehler beim Laden</option>';
            modelSelect.disabled = true;
        }
        
        if (modelInfo) {
            modelInfo.innerHTML = '‚ùå Fehler beim Laden der Ollama-Modelle. Fallback-Protokolle verf√ºgbar.';
            modelInfo.className = 'mt-2 p-3 bg-red-50 rounded-lg text-sm text-red-700';
            modelInfo.style.display = 'block';
        }
    }
}

// Process transcript with real names for protocol generation
function processTranscriptWithNames() {
    if (!currentTranscriptData || !currentTranscriptData.segments) {
        console.log('‚ö†Ô∏è No transcript data available');
        return currentTranscriptData?.transcript || '';
    }
    
    let processedTranscript = '';
    
    // Process each segment with speaker names
    currentTranscriptData.segments.forEach(segment => {
        const speaker = segment.speaker;
        const text = segment.text;
        const start = segment.start;
        const end = segment.end;
        
        // Get the real name for this speaker
        const realName = speakerNames[speaker] || speaker;
        
        // Add to processed transcript
        processedTranscript += `[${formatTime(start)}-${formatTime(end)}] ${realName}: ${text}\n`;
    });
    
    // If no segments, use plain transcript
    if (!processedTranscript) {
        processedTranscript = currentTranscriptData.transcript;
    }
    
    console.log('üìù Processed transcript with names:', processedTranscript.length + ' characters');
    return processedTranscript;
}

// Create speaker list with real names
function createSpeakerList() {
    const speakers = [];
    
    // Convert speakerNames object to array format expected by backend
    Object.keys(speakerNames).forEach(speakerId => {
        speakers.push({
            id: speakerId,
            name: speakerNames[speakerId],
            original_id: speakerId
        });
    });
    
    console.log('üë• Created speaker list:', speakers);
    return speakers;
}

// Generate simple fallback protocol
function generateSimpleFallbackProtocol() {
    if (!currentTranscriptData) {
        return 'Keine Transkriptionsdaten verf√ºgbar.';
    }
    
    const transcript = currentTranscriptData.transcript;
    const segments = currentTranscriptData.segments || [];
    const metadata = currentTranscriptData.metadata || {};
    
    // Basic protocol structure
    let protocol = `# Meeting-Protokoll\n`;
    protocol += `*Automatisch generiert am ${new Date().toLocaleString('de-DE')}*\n\n`;
    
    // Meeting info
    protocol += `## Meeting-Informationen\n`;
    protocol += `- **Dauer:** ${metadata.duration_formatted || 'Unbekannt'}\n`;
    protocol += `- **Sprache:** ${metadata.language || 'Deutsch'}\n`;
    protocol += `- **Sprecher:** ${metadata.speaker_count || 1}\n`;
    protocol += `- **Segmente:** ${segments.length}\n\n`;
    
    // Participants
    protocol += `## Teilnehmer\n`;
    Object.values(speakerNames).forEach(name => {
        protocol += `- ${name}\n`;
    });
    protocol += `\n`;
    
    // Transcript with timestamps
    protocol += `## Transkription\n`;
    if (segments.length > 0) {
        segments.forEach(segment => {
            const speaker = speakerNames[segment.speaker] || segment.speaker;
            const timeStamp = `${formatTime(segment.start)}-${formatTime(segment.end)}`;
            protocol += `**${speaker}** *(${timeStamp})*: ${segment.text}\n\n`;
        });
    } else {
        protocol += `${transcript}\n\n`;
    }
    
    // Basic structure for action items
    protocol += `## Erkannte Themen\n`;
    protocol += `*Automatische Analyse:*\n`;
    
    // Simple keyword analysis
    const words = transcript.toLowerCase().split(/\s+/);
    const keywords = {
        'entscheidung': ['entscheidung', 'beschluss', 'entscheiden', 'beschlie√üen'],
        'aufgabe': ['aufgabe', 'todo', 'erledigen', 'zust√§ndig', 'verantwortlich'],
        'termin': ['termin', 'deadline', 'bis', 'datum', 'zeit'],
        'problem': ['problem', 'issue', 'fehler', 'schwierigkeit']
    };
    
    Object.keys(keywords).forEach(category => {
        const matches = keywords[category].filter(word => words.includes(word));
        if (matches.length > 0) {
            protocol += `- **${category.charAt(0).toUpperCase() + category.slice(1)}** erw√§hnt (${matches.length}x)\n`;
        }
    });
    
    protocol += `\n## N√§chste Schritte\n`;
    protocol += `- [ ] Protokoll √ºberpr√ºfen und vervollst√§ndigen\n`;
    protocol += `- [ ] Action Items definieren\n`;
    protocol += `- [ ] N√§chstes Meeting planen\n\n`;
    
    protocol += `---\n`;
    protocol += `*Dieses Protokoll wurde automatisch aus der Audio-Transkription generiert.*\n`;
    protocol += `*F√ºr bessere Qualit√§t verwenden Sie ein KI-Modell √ºber Ollama.*\n`;
    
    return protocol;
}

// Copy protocol to clipboard
function copyProtocolToClipboard() {
    const protocolText = document.getElementById('protocolText');
    if (!protocolText) return;
    
    navigator.clipboard.writeText(protocolText.textContent).then(() => {
        // Show success message
        const button = event.target;
        const originalText = button.innerHTML;
        button.innerHTML = '‚úÖ Kopiert!';
        button.style.backgroundColor = '#10b981';
        
        setTimeout(() => {
            button.innerHTML = originalText;
            button.style.backgroundColor = '';
        }, 2000);
    }).catch(err => {
        console.error('Failed to copy: ', err);
        alert('Fehler beim Kopieren. Bitte manuell ausw√§hlen und kopieren.');
    });
}

// Download protocol as file
function downloadProtocolAsFile() {
    const protocolText = document.getElementById('protocolText');
    if (!protocolText) return;
    
    const content = protocolText.textContent;
    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
    const filename = `Meeting-Protokoll_${timestamp}.md`;
    
    const blob = new Blob([content], { type: 'text/markdown' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

// Update protocol model info display
function updateProtocolModelInfo() {
    const modelSelect = document.getElementById('protocolModelSelect');
    const modelInfo = document.getElementById('modelInfo');
    
    if (!modelSelect || !modelInfo) return;
    
    selectedProtocolModel = modelSelect.value;
    
    if (!selectedProtocolModel) {
        modelInfo.style.display = 'none';
        return;
    }
    
    // Find model info
    const modelData = ollamaModels.find(m => m.name === selectedProtocolModel);
    
    if (modelData) {
        modelInfo.innerHTML = `
            <div class="flex items-center space-x-3">
                <div class="text-green-600">ü§ñ</div>
                <div class="flex-grow">
                    <div class="font-medium">${modelData.name}</div>
                    <div class="text-sm text-gray-600">
                        ${modelData.parameter_size} ‚Ä¢ ${modelData.size_formatted} ‚Ä¢ ${modelData.quantization}
                        ${modelData.recommended ? ' ‚Ä¢ ‚≠ê Empfohlen' : ''}
                    </div>
                </div>
            </div>
        `;
        modelInfo.className = 'mt-2 p-3 bg-green-50 rounded-lg text-sm';
        modelInfo.style.display = 'block';
    } else {
        modelInfo.style.display = 'none';
    }
}

// Generate protocol with speaker names and selected model
async function generateProtocol() {
    console.log('üéØ Generate Protocol clicked!');
    
    const protocolBtn = document.getElementById('protocolBtn');
    const protocolContent = document.getElementById('protocolContent');
    
    if (!currentTranscriptData) {
        alert('Keine Transkriptionsdaten verf√ºgbar.');
        return;
    }
    
    // Get selected model
    const selectedModel = selectedProtocolModel || document.getElementById('protocolModelSelect')?.value;
    console.log('ü§ñ Selected model for protocol:', selectedModel);
    
    // Disable button and show loading
    if (protocolBtn) {
        protocolBtn.disabled = true;
        protocolBtn.innerHTML = `
            <div class="flex items-center justify-center space-x-2">
                <div class="w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin"></div>
                <span>Protokoll wird generiert...</span>
            </div>
        `;
    }
    
    // Show loading in content area
    if (protocolContent) {
        protocolContent.innerHTML = `
            <div class="text-center py-8">
                <div class="loading-spinner mx-auto mb-4"></div>
                <h3 class="text-lg font-semibold text-gray-800 mb-2">ü§ñ KI generiert Ihr Meeting-Protokoll</h3>
                <p class="text-gray-600 mb-2">Modell: <strong>${selectedModel || 'Fallback'}</strong></p>
                <div class="text-sm text-gray-500">
                    <p>‚ú® Analysiert Transkript und Sprecher-Zuordnungen...</p>
                    <p>üìù Erstellt strukturiertes Protokoll mit Action Items...</p>
                    <p>‚è±Ô∏è Dies kann 10-30 Sekunden dauern</p>
                </div>
            </div>
        `;
    }
    
    try {
        // Prepare transcript with real names
        const processedTranscript = processTranscriptWithNames();
        const processedSpeakers = createSpeakerList();
        
        console.log('üìù Processed transcript length:', processedTranscript.length);
        console.log('üë• Processed speakers:', processedSpeakers);
        
        // Call protocol generation API with model selection
        const requestData = {
            transcript: processedTranscript,
            speakers: processedSpeakers,
            metadata: currentTranscriptData.metadata || {},
            model: selectedModel  // Include selected model
        };
        
        console.log('üöÄ Sending protocol generation request:', requestData);
        
        const response = await fetch('/api/v1/generate-protocol', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(requestData)
        });
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const result = await response.json();
        console.log('‚úÖ Protocol generation response:', result);
        
        // Display protocol
        if (result.success && result.protocol) {
            displayGeneratedProtocol(result);
        } else {
            throw new Error(result.error || 'Protokoll-Generierung fehlgeschlagen');
        }
        
    } catch (error) {
        console.error('‚ùå Protocol generation failed:', error);
        
        // Show error with retry options
        if (protocolContent) {
            protocolContent.innerHTML = `
                <div class="bg-red-50 border border-red-200 rounded-lg p-6">
                    <div class="flex items-start space-x-3">
                        <div class="text-red-500 text-xl">‚ö†Ô∏è</div>
                        <div class="flex-grow">
                            <h3 class="text-red-800 font-medium mb-2">Protokoll-Generierung fehlgeschlagen</h3>
                            <p class="text-red-700 text-sm mb-3">${error.message}</p>
                            
                            <div class="text-sm text-red-600 space-y-1 mb-4">
                                <p><strong>M√∂gliche L√∂sungen:</strong></p>
                                <ul class="list-disc ml-4 space-y-1">
                                    <li>√úberpr√ºfen Sie, ob Ollama l√§uft: <code class="bg-red-100 px-1 rounded">ollama serve</code></li>
                                    <li>Vergewissern Sie sich, dass das Modell verf√ºgbar ist</li>
                                    <li>Probieren Sie ein anderes Modell aus</li>
                                    <li>Verwenden Sie das Fallback-Protokoll</li>
                                </ul>
                            </div>
                            
                            <div class="flex space-x-3">
                                <button 
                                    onclick="generateProtocol()" 
                                    class="bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded-lg text-sm font-medium transition-colors">
                                    üîÑ Erneut versuchen
                                </button>
                                <button 
                                    onclick="generateFallbackProtocolOnly()" 
                                    class="bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded-lg text-sm font-medium transition-colors">
                                    üìù Fallback-Protokoll
                                </button>
                                <button 
                                    onclick="loadOllamaModels()" 
                                    class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg text-sm font-medium transition-colors">
                                    üîÑ Modelle neu laden
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }
        
    } finally {
        // Re-enable button
        if (protocolBtn) {
            protocolBtn.disabled = false;
            protocolBtn.innerHTML = 'ü§ñ Protokoll generieren';
        }
    }
}

// Display generated protocol with enhanced UI
function displayGeneratedProtocol(result) {
    const protocolContent = document.getElementById('protocolContent');
    
    if (!protocolContent) return;
    
    const modelUsed = result.model_used || 'Unbekannt';
    const method = result.method || 'unknown';
    const generationTime = result.generation_time ? new Date(result.generation_time).toLocaleString('de-DE') : 'Unbekannt';
    
    protocolContent.innerHTML = `
        <div class="bg-green-50 border border-green-200 rounded-lg p-4 mb-6">
            <div class="flex items-center justify-between mb-2">
                <h3 class="text-green-800 font-semibold flex items-center">
                    <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                    </svg>
                    Meeting-Protokoll erfolgreich generiert
                </h3>
                <div class="flex space-x-2">
                    <button 
                        onclick="copyProtocolToClipboard()" 
                        class="bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded text-sm font-medium transition-colors flex items-center space-x-1">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                        </svg>
                        <span>Kopieren</span>
                    </button>
                    <button 
                        onclick="downloadProtocolAsFile()" 
                        class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded text-sm font-medium transition-colors flex items-center space-x-1">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                        </svg>
                        <span>Download</span>
                    </button>
                </div>
            </div>
            <div class="text-green-700 text-sm grid grid-cols-2 md:grid-cols-4 gap-4">
                <div><strong>Methode:</strong> ${method === 'ollama' ? 'ü§ñ KI-generiert' : 'üìù Fallback'}</div>
                <div><strong>Modell:</strong> ${modelUsed}</div>
                <div><strong>Erstellt:</strong> ${generationTime}</div>
                <div><strong>Sprecher:</strong> ${result.speakers?.length || 0}</div>
            </div>
        </div>
        
        <div class="bg-white rounded-lg border">
            <div class="p-4 border-b bg-gray-50">
                <h4 class="font-medium text-gray-800">üìã Generiertes Protokoll</h4>
            </div>
            <div class="p-6">
                <pre id="protocolText" class="whitespace-pre-wrap text-sm font-mono bg-gray-50 p-4 rounded border overflow-auto max-h-96 leading-relaxed">${result.protocol}</pre>
            </div>
        </div>
        
        <div class="mt-4 p-4 bg-blue-50 border border-blue-200 rounded-lg">
            <h4 class="font-medium text-blue-800 mb-2">üîÑ Weitere Optionen</h4>
            <div class="flex flex-wrap gap-2">
                <button 
                    onclick="generateProtocolWithDifferentModel()" 
                    class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-2 rounded text-sm font-medium transition-colors">
                    üîÑ Mit anderem Modell generieren
                </button>
                <button 
                    onclick="generateFallbackProtocolOnly()" 
                    class="bg-gray-600 hover:bg-gray-700 text-white px-3 py-2 rounded text-sm font-medium transition-colors">
                    üìù Einfaches Protokoll anzeigen
                </button>
                <button 
                    onclick="editSpeakerNames()" 
                    class="bg-yellow-600 hover:bg-yellow-700 text-white px-3 py-2 rounded text-sm font-medium transition-colors">
                    ‚úèÔ∏è Sprecher-Namen bearbeiten
                </button>
            </div>
        </div>
    `;
    
    // Scroll to protocol
    protocolContent.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
}

// Generate protocol with different model (allows comparison)
function generateProtocolWithDifferentModel() {
    // Show model selection and regenerate
    const currentModel = selectedProtocolModel;
    
    if (confirm(`M√∂chten Sie das Protokoll mit einem anderen Modell generieren?\n\nAktuell: ${currentModel}\n\nDas aktuelle Protokoll bleibt erhalten.`)) {
        // Could open a modal with model selection or just regenerate with current selection
        generateProtocol();
    }
}

// Generate fallback protocol only
function generateFallbackProtocolOnly() {
    const protocolContent = document.getElementById('protocolContent');
    if (!protocolContent || !currentTranscriptData) return;
    
    const fallbackProtocol = generateSimpleFallbackProtocol();
    
    const result = {
        protocol: fallbackProtocol,
        method: 'fallback',
        model_used: 'Einfache Struktur',
        speakers: Object.keys(speakerNames).map(key => ({ name: speakerNames[key] })),
        generation_time: new Date().toISOString()
    };
    
    displayGeneratedProtocol(result);
}

// Edit speaker names (go back to configuration)
function editSpeakerNames() {
    const speakerNamesSection = document.getElementById('speakerNamesSection');
    if (speakerNamesSection) {
        speakerNamesSection.scrollIntoView({ behavior: 'smooth' });
        
        // Highlight the section briefly
        speakerNamesSection.style.background = '#fef3c7';
        setTimeout(() => {
            speakerNamesSection.style.background = '';
        }, 2000);
    }
}

// Prompt generation and display
async function getStructuredProtocolPrompt() {
    console.log('üéØ Get Structured Protocol Prompt clicked!');
    
    if (!currentTranscriptData) {
        alert('Keine Transkriptionsdaten verf√ºgbar.');
        return;
    }
    
    try {
        // Prepare transcript with real names
        const processedTranscript = processTranscriptWithNames();
        const processedSpeakers = createSpeakerList();
        
        console.log('üìù Generating structured prompt...');
        
        const requestData = {
            transcript: processedTranscript,
            speakers: processedSpeakers
        };
        
        const response = await fetch('/api/v1/protocol/prompt', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(requestData)
        });
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const result = await response.json();
        console.log('‚úÖ Structured prompt generated:', result);
        
        // Display prompt in a modal or copy to clipboard
        if (result.success && result.prompt) {
            displayStructuredPrompt(result);
        } else {
            throw new Error(result.error || 'Prompt-Generierung fehlgeschlagen');
        }
        
    } catch (error) {
        console.error('‚ùå Prompt generation failed:', error);
        alert(`Prompt-Generierung fehlgeschlagen: ${error.message}`);
    }
}

function displayStructuredPrompt(result) {
    const promptData = result.prompt;
    const usageExample = result.usage_example;
    
    // Create modal with structured prompt
    const modal = document.createElement('div');
    modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
    modal.innerHTML = `
        <div class="bg-white rounded-lg max-w-4xl w-full mx-4 max-h-[90vh] overflow-y-auto">
            <div class="p-6">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-lg font-semibold text-gray-800">üìù Strukturierter 9-Punkte-Protokoll Prompt</h3>
                    <button onclick="this.closest('.fixed').remove()" class="text-gray-400 hover:text-gray-600">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
                
                <div class="space-y-4">
                    <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                        <h4 class="font-medium text-blue-800 mb-2">üìä Prompt-Informationen</h4>
                        <div class="grid grid-cols-2 gap-4 text-sm">
                            <div>
                                <span class="font-medium text-blue-700">Format:</span> ${promptData.format}
                            </div>
                            <div>
                                <span class="font-medium text-blue-700">Sprecher:</span> ${promptData.speaker_count}
                            </div>
                            <div>
                                <span class="font-medium text-blue-700">Transkript-L√§nge:</span> ${promptData.transcript_length} Zeichen
                            </div>
                            <div>
                                <span class="font-medium text-blue-700">Erwartete Sektionen:</span> ${promptData.expected_sections.length}
                            </div>
                        </div>
                    </div>
                    
                    <div class="bg-gray-50 border border-gray-200 rounded-lg p-4">
                        <h4 class="font-medium text-gray-800 mb-2">üéØ Strukturierter Prompt</h4>
                        <div class="bg-white border rounded p-3 text-sm font-mono whitespace-pre-wrap max-h-60 overflow-y-auto">
${promptData.content}
                        </div>
                        <div class="mt-2 flex space-x-2">
                            <button onclick="copyToClipboard('${promptData.content.replace(/'/g, "\\'")}', 'Prompt kopiert!')" 
                                    class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded text-sm">
                                üìã Prompt kopieren
                            </button>
                        </div>
                    </div>
                    
                    <div class="bg-green-50 border border-green-200 rounded-lg p-4">
                        <h4 class="font-medium text-green-800 mb-2">üí° Verwendungsbeispiel</h4>
                        <p class="text-sm text-green-700 mb-2">${usageExample.description}</p>
                        <div class="bg-white border rounded p-3 text-sm font-mono">
                            <pre class="whitespace-pre-wrap">${JSON.stringify(usageExample.api_call_example, null, 2)}</pre>
                        </div>
                        <div class="mt-2">
                            <button onclick="copyToClipboard('${JSON.stringify(usageExample.api_call_example, null, 2).replace(/'/g, "\\'")}', 'API-Beispiel kopiert!')" 
                                    class="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded text-sm">
                                üìã API-Beispiel kopieren
                            </button>
                        </div>
                    </div>
                    
                    <div class="bg-yellow-50 border border-yellow-200 rounded-lg p-4">
                        <h4 class="font-medium text-yellow-800 mb-2">üîß Erwartete Protokoll-Struktur</h4>
                        <div class="text-sm text-yellow-700 space-y-1">
                            ${promptData.expected_sections.map((section, i) => `
                                <div class="flex items-center space-x-2">
                                    <span class="font-medium">${i + 1}.</span>
                                    <span>${section}</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
                
                <div class="mt-6 text-center">
                    <button onclick="this.closest('.fixed').remove()" 
                            class="bg-gray-500 hover:bg-gray-600 text-white px-6 py-2 rounded">
                        Schlie√üen
                    </button>
                </div>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
}

// ...existing code...
    </script>
</body>
</html>